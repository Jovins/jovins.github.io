<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>为什么使用Texture | Jovins Blog</title>
    <meta name="description" content="Work Hard, Play Hard">
    <link rel="icon" href="/favicon.ico">
  <meta name="theme-color" content="#3eaf7c">
  <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/assets/css/0.styles.fa6af71c.css" as="style"><link rel="preload" href="/assets/js/app.645de36e.js" as="script"><link rel="preload" href="/assets/js/25.584ca57e.js" as="script"><link rel="prefetch" href="/assets/js/10.eb273c57.js"><link rel="prefetch" href="/assets/js/100.1f4851a6.js"><link rel="prefetch" href="/assets/js/101.2a49a1ab.js"><link rel="prefetch" href="/assets/js/102.0cb85f20.js"><link rel="prefetch" href="/assets/js/103.b52c7c69.js"><link rel="prefetch" href="/assets/js/104.4412bf8a.js"><link rel="prefetch" href="/assets/js/105.3dc89f2c.js"><link rel="prefetch" href="/assets/js/106.c86ee8bc.js"><link rel="prefetch" href="/assets/js/107.b61d039d.js"><link rel="prefetch" href="/assets/js/108.d96bdab1.js"><link rel="prefetch" href="/assets/js/109.08bfc0f1.js"><link rel="prefetch" href="/assets/js/11.8b390e8b.js"><link rel="prefetch" href="/assets/js/110.690d99a2.js"><link rel="prefetch" href="/assets/js/111.ca5c403d.js"><link rel="prefetch" href="/assets/js/112.6c170a62.js"><link rel="prefetch" href="/assets/js/113.39d9608c.js"><link rel="prefetch" href="/assets/js/12.df1c45e8.js"><link rel="prefetch" href="/assets/js/13.247c5940.js"><link rel="prefetch" href="/assets/js/14.ad9ccb95.js"><link rel="prefetch" href="/assets/js/15.d9733c0d.js"><link rel="prefetch" href="/assets/js/16.3359d1d1.js"><link rel="prefetch" href="/assets/js/17.97ac7cd5.js"><link rel="prefetch" href="/assets/js/18.b24d44a3.js"><link rel="prefetch" href="/assets/js/19.c34d4a73.js"><link rel="prefetch" href="/assets/js/2.dacd214f.js"><link rel="prefetch" href="/assets/js/20.2e32e9ac.js"><link rel="prefetch" href="/assets/js/21.b186da30.js"><link rel="prefetch" href="/assets/js/22.ebea8b97.js"><link rel="prefetch" href="/assets/js/23.bfbe48cf.js"><link rel="prefetch" href="/assets/js/24.cea6c013.js"><link rel="prefetch" href="/assets/js/26.94fa318b.js"><link rel="prefetch" href="/assets/js/27.5c3bb545.js"><link rel="prefetch" href="/assets/js/28.2fb66889.js"><link rel="prefetch" href="/assets/js/29.b91c0a6b.js"><link rel="prefetch" href="/assets/js/3.7313ea5b.js"><link rel="prefetch" href="/assets/js/30.7f29df29.js"><link rel="prefetch" href="/assets/js/31.e1f530a1.js"><link rel="prefetch" href="/assets/js/32.eaa72b7f.js"><link rel="prefetch" href="/assets/js/33.542d027d.js"><link rel="prefetch" href="/assets/js/34.be43eb5e.js"><link rel="prefetch" href="/assets/js/35.adef513a.js"><link rel="prefetch" href="/assets/js/36.eca70d69.js"><link rel="prefetch" href="/assets/js/37.9566ea75.js"><link rel="prefetch" href="/assets/js/38.153a4495.js"><link rel="prefetch" href="/assets/js/39.08df67a7.js"><link rel="prefetch" href="/assets/js/4.2257a595.js"><link rel="prefetch" href="/assets/js/40.772594fe.js"><link rel="prefetch" href="/assets/js/41.b990c7c9.js"><link rel="prefetch" href="/assets/js/42.d27a3ad6.js"><link rel="prefetch" href="/assets/js/43.d26af3e6.js"><link rel="prefetch" href="/assets/js/44.0d6441b5.js"><link rel="prefetch" href="/assets/js/45.10916794.js"><link rel="prefetch" href="/assets/js/46.f624fc73.js"><link rel="prefetch" href="/assets/js/47.fa8baccd.js"><link rel="prefetch" href="/assets/js/48.58daadef.js"><link rel="prefetch" href="/assets/js/49.064fc123.js"><link rel="prefetch" href="/assets/js/5.b885bab0.js"><link rel="prefetch" href="/assets/js/50.bc5bec67.js"><link rel="prefetch" href="/assets/js/51.ba116ee1.js"><link rel="prefetch" href="/assets/js/52.22554eab.js"><link rel="prefetch" href="/assets/js/53.c1fcd2d0.js"><link rel="prefetch" href="/assets/js/54.5b5cd2fc.js"><link rel="prefetch" href="/assets/js/55.6e17f0de.js"><link rel="prefetch" href="/assets/js/56.556371f4.js"><link rel="prefetch" href="/assets/js/57.3952dd85.js"><link rel="prefetch" href="/assets/js/58.fec91d72.js"><link rel="prefetch" href="/assets/js/59.76652e5d.js"><link rel="prefetch" href="/assets/js/6.445f2e85.js"><link rel="prefetch" href="/assets/js/60.47570b43.js"><link rel="prefetch" href="/assets/js/61.2c453ca7.js"><link rel="prefetch" href="/assets/js/62.926da836.js"><link rel="prefetch" href="/assets/js/63.daa81298.js"><link rel="prefetch" href="/assets/js/64.b2ff83ac.js"><link rel="prefetch" href="/assets/js/65.666258af.js"><link rel="prefetch" href="/assets/js/66.4edac8d2.js"><link rel="prefetch" href="/assets/js/67.d87446c6.js"><link rel="prefetch" href="/assets/js/68.1e9dccd5.js"><link rel="prefetch" href="/assets/js/69.d4eeb7e0.js"><link rel="prefetch" href="/assets/js/7.22dc9c5b.js"><link rel="prefetch" href="/assets/js/70.036f9be7.js"><link rel="prefetch" href="/assets/js/71.ddf85cb1.js"><link rel="prefetch" href="/assets/js/72.74e2684e.js"><link rel="prefetch" href="/assets/js/73.71ebe8fc.js"><link rel="prefetch" href="/assets/js/74.0f773f6e.js"><link rel="prefetch" href="/assets/js/75.a7fa7d80.js"><link rel="prefetch" href="/assets/js/76.a62cb859.js"><link rel="prefetch" href="/assets/js/77.80adb570.js"><link rel="prefetch" href="/assets/js/78.d26b7cfb.js"><link rel="prefetch" href="/assets/js/79.6cc4f11a.js"><link rel="prefetch" href="/assets/js/8.001bf67a.js"><link rel="prefetch" href="/assets/js/80.1f880b90.js"><link rel="prefetch" href="/assets/js/81.e6478e45.js"><link rel="prefetch" href="/assets/js/82.c2b354db.js"><link rel="prefetch" href="/assets/js/83.2f284755.js"><link rel="prefetch" href="/assets/js/84.05d77ad9.js"><link rel="prefetch" href="/assets/js/85.613acc1e.js"><link rel="prefetch" href="/assets/js/86.2198e606.js"><link rel="prefetch" href="/assets/js/87.ffc979ab.js"><link rel="prefetch" href="/assets/js/88.c56ae228.js"><link rel="prefetch" href="/assets/js/89.ea11aeac.js"><link rel="prefetch" href="/assets/js/9.4c3a9bd4.js"><link rel="prefetch" href="/assets/js/90.e96d2dc9.js"><link rel="prefetch" href="/assets/js/91.51ec4669.js"><link rel="prefetch" href="/assets/js/92.095e417b.js"><link rel="prefetch" href="/assets/js/93.b606b221.js"><link rel="prefetch" href="/assets/js/94.dcf1e5c9.js"><link rel="prefetch" href="/assets/js/95.f5202eae.js"><link rel="prefetch" href="/assets/js/96.54651072.js"><link rel="prefetch" href="/assets/js/97.c0137e33.js"><link rel="prefetch" href="/assets/js/98.bd0bedf9.js"><link rel="prefetch" href="/assets/js/99.e0a69f1a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.fa6af71c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Jovins Blog</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/source/swift/" class="nav-link">Swift</a></div><div class="nav-item"><a href="/source/swiftui/" class="nav-link">SwiftUI</a></div><div class="nav-item"><a href="/source/summary/" class="nav-link router-link-active">Summary</a></div><div class="nav-item"><a href="/source/go/" class="nav-link">Go</a></div><div class="nav-item"><a href="/source/program/" class="nav-link">小程序</a></div><div class="nav-item"><a href="/source/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/source/git/" class="nav-link">Git</a></div><div class="nav-item"><a href="https://github.com/Jovins" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/source/swift/" class="nav-link">Swift</a></div><div class="nav-item"><a href="/source/swiftui/" class="nav-link">SwiftUI</a></div><div class="nav-item"><a href="/source/summary/" class="nav-link router-link-active">Summary</a></div><div class="nav-item"><a href="/source/go/" class="nav-link">Go</a></div><div class="nav-item"><a href="/source/program/" class="nav-link">小程序</a></div><div class="nav-item"><a href="/source/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/source/git/" class="nav-link">Git</a></div><div class="nav-item"><a href="https://github.com/Jovins" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading open"><span>技术杂谈</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/source/summary/" class="sidebar-link">Reading List</a></li><li><a href="/source/summary/Texture-note.html" class="sidebar-link">Texture 开发笔记</a></li><li><a href="/source/summary/Texture-why.html" class="active sidebar-link">为什么使用Texture</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/source/summary/Texture-why.html#原因" class="sidebar-link">原因</a></li><li class="sidebar-sub-header"><a href="/source/summary/Texture-why.html#优化思路" class="sidebar-link">优化思路</a></li><li class="sidebar-sub-header"><a href="/source/summary/Texture-why.html#texture注释" class="sidebar-link">Texture注释</a></li><li class="sidebar-sub-header"><a href="/source/summary/Texture-why.html#注意事项" class="sidebar-link">注意事项</a></li><li class="sidebar-sub-header"><a href="/source/summary/Texture-why.html#优缺点" class="sidebar-link">优缺点</a></li><li class="sidebar-sub-header"><a href="/source/summary/Texture-why.html#深度优化列表性能" class="sidebar-link">深度优化列表性能</a></li><li class="sidebar-sub-header"><a href="/source/summary/Texture-why.html#一些细节" class="sidebar-link">一些细节</a></li><li class="sidebar-sub-header"><a href="/source/summary/Texture-why.html#小结" class="sidebar-link">小结</a></li></ul></li><li><a href="/source/summary/Texture-official-concept.html" class="sidebar-link">Texture 基本概念</a></li><li><a href="/source/summary/Texture-official-layout.html" class="sidebar-link">Texture 布局</a></li><li><a href="/source/summary/UIScrollView-touch-conflict.html" class="sidebar-link">UIScrollView嵌套滚动解决手势冲突</a></li><li><a href="/source/summary/2018-reporter.html" class="sidebar-link">2018-小记</a></li><li><a href="/source/summary/iOS-Memory-explore.html" class="sidebar-link">iOS内存管理探究</a></li><li><a href="/source/summary/fastlane-auto-dev.html" class="sidebar-link">fastlane自动化开发组件</a></li><li><a href="/source/summary/dev-component.html" class="sidebar-link">组件化开发之开发小组件</a></li><li><a href="/source/summary/Resume-01.html" class="sidebar-link">总结上</a></li><li><a href="/source/summary/Resume-02.html" class="sidebar-link">总结中</a></li><li><a href="/source/summary/Resume-03.html" class="sidebar-link">总结下</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="为什么使用texture"><a href="#为什么使用texture" aria-hidden="true" class="header-anchor">#</a> 为什么使用Texture</h1> <h2 id="原因"><a href="#原因" aria-hidden="true" class="header-anchor">#</a> 原因</h2> <p>UITableView/UICollectionView的优化一直是iOS应用性能优化重要的一块。即使是iOS11+iPhone8这样的最新软硬件配置，在系统的信息app中滚动，仔细观察的话仍然能感到一定的掉帧现象。对于UI要求苛刻的苹果竟然在如此简单的tableView上无法达到60fps的帧率，可见优化滚动性能的背后并不简单。</p> <p>理想状态下，iOS的帧率应该保持在60fps。然而很多情况下用户操作时会感觉到掉帧或者『不跟手』。原因可能有很多，比如以下几种:</p> <ul><li><p><strong>CPU(主要是主线程)/GPU负担过重或者不均衡</strong>（诸如mask/cornerRadius/drawRect/opaque带来offscreen
rendering/blending等等）。由于所有的UIView都是由CALayer来负责显示，因此对Core
Animation的了解就变得尤为重要。这里推荐Nick Lockwood的<em>Core Animation: AdvancedTechniques</em>一书，其中有对Core Animation的性能有着非常详尽的梳理和剖析。</p></li> <li><p><strong>Autolayout布局性能瓶颈</strong>，约束计算时间会随着数量呈指数级增长，并且必须在主线程执行。这也是为何Texture抛弃了Autolayout而设计了自己的布局系统的<a href="https://github.com/facebookarchive/AsyncDisplayKit/issues/196" target="_blank" rel="noopener noreferrer">重要原因之一<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。Autolayout在单个View开发时能带来很多便利，而在一些需要高性能的场景下需要谨慎使用。</p></li> <li><p>尽管从iPhone4S(A5)开始CPU已经采用多核，**然而对于大多数app来说，多线程协作并没有被充分利用。**换句话说，在app卡顿（主线程所占用的核心满负荷）时，往往CPU的其他核心几乎无事可做。一般情况下，由于主线程承担了绝大部分的工作，如果能把主线程的任务转移一部给其他线程进行异步处理，就可以马上享受到并发带来的性能提升。这应该也是AsyncDisplayKit得名的原因之一。</p></li></ul> <p>UIKit的单线程设计也有一定的历史原因。早在十年前iOS SDK刚问世的时候，mobile
SDK还是一个非常新的概念，更没有移动多核CPU的存在，因此当时的重点是简单可靠，大多数API都没有支持相对复杂的异步操作。时至今日，如果要完全重构UIKit使之支持异步绘制和布局，对于兼容已有海量的app，难度可想而知。在iOS10中虽然对UICollectionView/UITableView做了一定的预加载优化（WWDC2016 Session219），然而并没有从根本上解决主线程布局和渲染的问题。</p> <h2 id="优化思路"><a href="#优化思路" aria-hidden="true" class="header-anchor">#</a> 优化思路</h2> <p>当用户开始滚动或点击一个View，所有的事件都会被送到主线程等待处理。此时主线程能否抽出足够充裕的时间来处理变得极为重要，尤其是在连续操作（如UIGestureRecognizer）时，每次touchMoved事件处理都会占用主线程一定的时间（如新的UIImageView进入视图，主线程开始处理布局或者图片解码，而这些需要连续占用大量CPU时间）。如果一个操作耗时超过16ms(1000ms/60fps)，那就意味着下一帧无法及时得到处理，引起丢帧。</p> <p><img src="/assets/img/texture-why-01.aa159a32.png" alt="img"></p> <p>如何能将主线程的压力尽可能减轻成为优化的首要目标。</p> <ol><li>针对Autolayout性能优化：提前计算并缓存cell的layout。<a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="noopener noreferrer">forkingdog<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>省去中间滑动过程中的计算，直接计算目标区域cell。<a href="https://github.com/johnil/VVeboTableViewDemo" target="_blank" rel="noopener noreferrer">VVebotableViewDemo<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>弃用Autolayout，采用手动布局计算。这样虽然可以换来最高的性能，但是代价是编写和维护的不便，对于经常改动或者性能要求不高的场景并不一定值得。</li> <li>自行<a href="https://github.com/ibireme/YYAsyncLayer" target="_blank" rel="noopener noreferrer">异步渲染Layer<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>iOS11列表的prefetch API，只是并没有解决Autolayout的性能，同时也受到系统版本限制。</li></ol> <p><strong>Texture的基本思路：异步</strong></p> <p>对于一般的开发者，自己重新实现一整套异步布局和渲染机制是非常困难的，但是Texture做到了。</p> <p><code>Texture</code>前身是AsyncDisplayKit，是2012年由Facebook开始着手开发，并于2014年出品的高性能显示类库，主要作者是Scott Goodson<a href="https://github.com/appleguy" target="_blank" rel="noopener noreferrer">appleguy<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>曾经参与了多个iOS版本系统的开发，包括UIKit以及一些系统原生app，后来加入Facebook并参与了Texture的开发并应用到Paper，因此该库有机会从相对底层的角度来进行一系列的优化。同时由于和Instagram同处于FB家族，因此也迅速加入了IGListKit的支持。</p> <p>在Scott介绍Texture的视频中，总结了一下三点占用大量CPU时间的『元凶』（虽然仍然可能有以上提到的其他原因，但Texture最主要集中于这三点进行优化：</p> <ol><li><strong>渲染</strong>，对于大量图片，或者大量文字（尤其是CJK字符）混合在一起时。而文字区域的大小和布局，恰恰依赖着渲染的结果。Texture尽可能后台线程进行渲染，完成后再同步回主线程相应的UIView。</li> <li><strong>布局</strong>。Texture完全弃用了Autolayout，另辟蹊径实现了自己的布局和缓存机制。</li> <li>系统objects的<strong>创建与销毁</strong>。由于UIKit封装了CALayer以支持触摸等显示以外的操作，耗时也相应增加。而这些同样也需要在主线程上操作。Texture基于Node的设计，突破了UIKit线程的限制。</li></ol> <p>既然同步就意味着阻塞，那就异步放到其他线程去做，在需要主线程时再同步回来。</p> <p><img src="/assets/img/texture-why-02.7069e5d1.png" alt="img"></p> <p>对于一般UIView和CALayer来说，因为不是线程安全的，任何相关操作都需要在主线程进行。正如UIView可以弥补CALayer无法处理用户事件的不足一样，Texture引入了Node的概念来解决UIView/CALayer只能在主线程上操作的限制（不由让人想起『Abstract layer can solve many problems, except problem of having too many abstract layers.』）。</p> <p>Texture主要特点如下：</p> <ul><li><p>每个Node对应相应的UIView或者CALayer，从开发者的角度而言，只需要将初始化UIView的代码稍作修改，替换为创建ASDisplayNode即可。在不需要接受用户操作的Node上可以开启isLayerBacked，直接使用CALayer进一步降低开销。根据Scott的研究UIView的开销大约是CALayer的5倍。</p></li> <li><p>Node默认是异步布局/渲染，只有在需要将frame/contents等同步到UIView上才会回到主线程，使其空出更多的时间处理其他事件。</p></li> <li><p>Texture只有在认为需要的时候才会异步地为Node加载相应的View，因此创建Node的开销变得非常低。同时Node是线程安全的，可以在任意queue上创建和设置属性。</p></li> <li><p>Texture不仅有与UIView对应的大部分控件（如ASButtonNode、ASTextNode、ASImageNode、ASTableNode等等），同时也bridge了大多数UIView的方法和属性，可以非常方便的操作frame/backgroundColor/addSubnode等，因此一般情况下只要对Node进行操作，Texture就会在适当的时候同步到其View。如果需要的话，当相应的View加载之后（或访问node.view手动触发加载），也可以通过node.view的方式直接访问，回到我们熟悉的UIKit。</p></li> <li><p>当实现自定义View的时候，ASDisplayNode提供了一个初始化方法initWithViewBlock/initWithLayerBlock，就可以将任意UIView/CALayer用Node包裹起来（被包裹的view可以使用autolayout），从而与Texture的其他组件相结合。虽然这样创建的Node与一般view在布局和渲染上的差异不大，但是由于Node管理着何时何地加载view，我们仍然能得到一定的性能提升。</p></li></ul> <p>举例来说，当使用UIKit创建一个UIImageView：</p> <div class="language-objective-c extra-class"><pre class="language-text"><code>_imageView = [[UIImageView alloc] init];
_imageView.image = [UIImage imageNamed:@&quot;hello&quot;];
_imageView.frame = CGRectMake(10.0f, 10.0f, 40.0f, 40.0f);
[self.view addSubview:_imageView];
</code></pre></div><p>使用Texture后只要稍加改动：</p> <div class="language-objective-c extra-class"><pre class="language-text"><code>_imageNode = [[ASImageNode alloc] init];
_imageNode.image = [UIImage imageNamed:@&quot;hello&quot;];
_imageNode.frame = CGRectMake(10.0f, 10.0f, 40.0f, 40.0f);
[self.view addSubview:_imageNode.view];
</code></pre></div><p>虽然只是简单的把View替换成了Node，然而和UIImageView不同的是，此时Texture已经在悄悄使用另一个线程进行图片解码，从而大大降低新的用户操作到来时主线程被阻塞的概率，使每一个回调都能得到及时的处理。实践中将会有更加复杂的情况，有兴趣的话可以参考项目中的Example目录，有20多个不同场景下的示例项目。</p> <h2 id="texture注释"><a href="#texture注释" aria-hidden="true" class="header-anchor">#</a> Texture注释</h2> <ol><li>在ASDisplayNode.h中有相当多的注释，其中displaysAsynchronously属性大致描述了异步渲染的步骤：</li></ol> <blockquote><ul><li>Asynchronous rendering proceeds as follows:</li> <li>When the view is initially added to the hierarchy, it has -needsDisplay true.</li> <li>After layout, Core Animation will call -display on the _ASDisplayLayer</li> <li>-display enqueues a rendering operation on the displayQueue</li> <li>When the render block executes, it calls the delegate display method
(-drawRect:… or -display)</li> <li>The delegate provides contents via this method and an operation is added to
the asyncdisplaykit_async_transaction</li> <li>Once all rendering is complete for the current
asyncdisplaykit_async_transaction,</li> <li>the completion for the block sets the contents on all of the layers in the
same frame</li></ul></blockquote> <p>ASDisplayNode还有一个属性shouldRasterizeDescendants。</p> <blockquote><p>/**</p> <ul><li>@abstract Whether to draw all descendant nodes’ layers/views into this node’s
layer/view’s backing store.</li> <li>@discussion</li> <li>When set to YES, causes all descendant nodes’ layers/views to be drawn
directly into this node’s layer/view’s backing</li> <li>store. Defaults to NO.</li> <li>If a node’s descendants are static (never animated or never change attributes
after creation) then that node is a</li> <li>good candidate for rasterization. Rasterizing descendants has two main
benefits:</li> <li><ol><li>Backing stores for descendant layers are not created. Instead the layers
are drawn directly into the rasterized</li></ol></li> <li>container. This can save a great deal of memory.</li> <li><ol start="2"><li>Since the entire subtree is drawn into one backing store, compositing and
blending are eliminated in that subtree</li></ol></li> <li>which can help improve animation/scrolling/etc performance.</li> <li>Rasterization does not currently support descendants with transform,
sublayerTransform, or alpha. Those properties</li> <li>will be ignored when rasterizing descendants.</li> <li>Note: this has nothing to do with -[CALayer shouldRasterize], which doesn’t
work with ASDisplayNode’s asynchronous</li> <li>rendering model.</li></ul> <p>*/</p></blockquote> <p>当我们不需要分别关注单个CALayer，也不需要对他们进行操作时，就可以将所有的子node都合并到父node的backing
store一并绘制，从而达到节省内存和提高性能的目的。</p> <h2 id="注意事项"><a href="#注意事项" aria-hidden="true" class="header-anchor">#</a> 注意事项</h2> <ul><li><p>Texture不支持Storyboard和Autolayout，但是可以与使用Autolayout的view兼容共存。同样React native和Component
Kit等其他Facebook出品的iOS库也不支持Storyboard。</p></li> <li><p>由于Node的异步渲染，很有可能在其View到达屏幕之后，内容仍然在渲染过程中。此时需要额外考虑每个Node的placeholder状态，使用户不至于看到一片空白。</p></li> <li><p>在使用ASDisplayNode初始化initWithViewBlock时，由于Node需要在适当的时候调用该block来创建view，因此并不会立即调用block（block可能capture其他变量，例如self），而是存在一个ivar当中。如果该view始终没被创建，而此时拥有该node的父元素被销毁，容易造成retain
cycle导致memory leak。</p></li></ul> <h2 id="优缺点"><a href="#优缺点" aria-hidden="true" class="header-anchor">#</a> 优缺点</h2> <p><strong>优点</strong></p> <ul><li>实现一个layout的视角从专注view之间的constraint转变成对定义多个view子区域的划分，抽象层级变高，可读性大大增强。</li> <li>由于ASDisplayNode的显示是异步的，因此无论布局是否依赖于显示结果，都可以在主线程以外进行，并且有缓存，性能有很大提升。</li> <li>借用css成熟的flexbox布局模型，有大量现成资料和案例来学习，避免了新造轮子的尴尬。</li> <li>由于Texture是开源的，调试难度大大降低。</li> <li>布局规则可以脱离实际布局对象进行独立声明，容易复用。</li></ul> <p><strong>缺点</strong></p> <ul><li>由于与iOS原生布局方式完全不同，学习适应需要一定时间（当然如果flexBox渐渐成为前端标准，花一些时间了解也是完全值得的。）</li> <li>对于ASDK依赖非常重，对于需要使用flexBox布局的view，只能重新使用ASDisplayNode来实现。如果不方便重新写，只能选用类似Yoga的独立框架来实现UIView的流式布局。</li> <li>虽然是声明式布局，然而相对css而言仍较为繁琐。去年我曾经到Pinterest与Scott有过一些当面交流，也尝试说服他们做一些DSL来简化布局声明，但是目前由于ASDK的复杂性和基础性（类似UIKit），他们仍然将大部分时间放在优化异步渲染和布局性能，并没有太多精力在layout的语法上做出进一步突破。</li></ul> <h2 id="深度优化列表性能"><a href="#深度优化列表性能" aria-hidden="true" class="header-anchor">#</a> 深度优化列表性能</h2> <p>说到视图性能，不能不提到UITableView，对于它的滚动性能的讨论和优化从未停止。在我们的探索过程中，尝试过以下一些措施：</p> <ul><li>Cell reuse，Apple原生支持</li> <li>estimated cell height，iOS8开始原生支持</li> <li>手动将计算完成的height缓存(或使用FDTemplateLayoutCell等框架自动计算)</li> <li>prefetch API，iOS10开始原生支持</li> <li>异步加载cell内容，文字图片</li> <li>圆角、opaque等普通UIView使用</li></ul> <p><strong>UITableView加载Cell的过程</strong></p> <ul><li><p>cellForRowAtIndexPath，读取model</p></li> <li><p>从reuse池中dequeue一个cell，调用prepareForReuse重置其状态</p></li> <li><p>将model装配到UITableViewCell当中去</p></li> <li><p>布局（耗时且无法缓存的Autolayout），渲染（文字和图片都很耗时），显示</p></li></ul> <p>这些操作都在cell将要进入window的一刹那发生，不难理解，在短短的16ms里（60fps）是很难完成这些任务的，尤其是当用户快速滚动的时候，大量任务堆积在runloop，情况变得雪上加霜。如果将滚动中的CPU占用情况用图表显示出来，大概是这样的:</p> <p><img src="/assets/img/texture-why-03.0d3f7451.png" alt></p> <p><strong>ASTableNode/ASCollectionNode开辟的新航路</strong></p> <p>ASTableNode以及其cellNode已经具备了异步布局和异步渲染的能力，即使没有做额外优化，仅仅利用A异步机制将耗时操作延后，相对于一般UITableView已经有了显著的提升。虽然性能锯齿仍然存在，但是将其转移到了后台线程以后，用户感受到的卡顿就已经不会那么明显了。然而在进入屏幕之后才开始渲染的时候会有短暂的白屏现象(等待渲染完成)再显示内容。既然渲染工作可以在显示之后再进行，那么类似的，也可以在显示之前的一段时间，把布局和渲染的工作预先完成。</p> <p>要达到这些目的，首先介绍一些相关的类：</p> <ul><li>ASTableNode/ASCollectionNode，可以认为是UITableView/UICollectionView的异步版本，内部包装了原来的UIKit的对应版本，并扩展了一系列功能使他们能够实现异步布局及渲染。</li> <li>ASInterfaceState，表示一个node不同的显示状态。其实每个ASDisplayNode都具备interfaceState属性，它主要的用武之地还是在tableNode/collectionNode之中。对于一个UITableViewCell来说，布局和渲染一般都是在cellForRowAtIndexpath同时完成，然而当需要精细处理任务时就需要把每一个不同的状态分开，降低某一瞬间由于CPU负载高导致卡顿的可能性。ASInterfaceState递进地分为5种状态:
<ul><li>None，该node在一段时间内不会进入屏幕</li> <li>MeasureLayout，可能会在一段时间后进入屏幕，应该准备layout和size计算</li> <li>Preload，加载所需要的数据，如下载图片，缓存读取等等</li> <li>Display，马上将要进入屏幕，开始进行渲染操作，显示包含的文字或者图片</li> <li>Visible，该node（所对应的view）至少有1个像素已经在屏幕内，正在显示</li></ul></li></ul> <p><img src="/assets/img/texture-why-04.d85f7906.png" alt></p> <p>对于每一个cell而言，原本需要在同一时间点进行的所有初始化/加载/布局/渲染等工作，现在被均匀分配到了不同的状态进行预处理。随着用户滚动列表，根据cell离屏幕的距离不同，设置相应的interfaceState并触发不同阶段的工作，达到均匀分配的目的。同时，由于不需要在主线程上进行，多个cell的工作可以通过共享后台线程来大幅提高并行效率。</p> <ul><li>ASDataController，与ASTableNode一一对应，负责代替ASTableNode管理delegate和dataSource的一系列方法，诸如初始化，插入，删除和一些代理方法等。</li> <li>ASRangeController，同样与ASTableNode一一对应，并且可以根据设备性能自定义布局、加载、渲染的工作indexPath区间，在滚动时动态高效地调整各cell的interfaceState来层层触发不同显示阶段的工作，对于流畅滚动起到了至关重要的作用。</li> <li>ASScrollDirection，定义了列表滚动的方向（上下左右）。在ASRangeController调整各阶段的工作区间时，一般在用户滚动的方向上需要多加载一些，而滚出屏幕的cell在一定时间内回到屏幕的概率较低，因此其分配到的资源也就相应少一些。</li></ul> <h2 id="一些细节"><a href="#一些细节" aria-hidden="true" class="header-anchor">#</a> 一些细节</h2> <p><strong>多线程</strong></p> <p>当同时layout多个node时，如何均匀分配工作到各个线程，同时单次不占用过多cpu时间？</p> <p>Texture是这么做的：</p> <p>获取当前设备上cpu的数量，并乘以每个cpu的工作量，如4 * 5 = 20，即同一批最多对20个node进行布局。（尽管没有找到严格的文档来说明这样的计算方式会带来最高的效率，但是应该要比不分批次处理更优，使占用的cpu时间片可控）
调用dispatch_apply，对同一批次20个node进行并行布局计算
每一批处理20个，直到所有都处理完</p> <p><strong>监听状态变化</strong></p> <p>不光ASDisplayNode本身会根据不同的state进行相应的工作，它同时也提供了一系列的方法供子类override，如didEnterPreloadState/didExitVisibleState等等。在实际应用中，由于子类通常会持有一些自己管理的资源（如图片），需要控制在显示/离开屏幕之际进行资源的分配/回收。由于每个时间点分的比较细，只要将工作均匀、合理地分配到相应的方法中，就可以实现非常精确高效的资源调度。</p> <p><strong>内存管理</strong></p> <p>ASRangeController经常需要管理屏幕外的node（可能同时有好几屏的内容同时进行布局计算和显示），通过预处理来减轻将来的工作量，是一个典型的『空间换时间』的办法，对于内存的压力自然就会上升。</p> <p>为此，ASRangeController提供了一些参数，让开发者可以自行决定每个stage所囊括的范围，达到控制内存的：</p> <p>ASLayoutRangeModeFull，此时用到的资源较多，同时用户体验也是最好的
ASLayoutRangeMinimum，比上一种类型节省一些资源
ASLayoutRangeModeVisibleOnly，在app退到后台的时候自动设置，将屏幕外的node所占用的资源释放，降低app在系统中被杀的概率
ASLayoutRangeModeLowMemory，比上一种更省内存，对于app退到后台，并且目前没有在屏幕上（可能在navigation stack里）的rangeController适用，最大程度释放资源
我们可以通过调用setTuningParameters的方式，对于每一种mode中的每一种layoutRangeType做出精细调整。同时，ASDK会自动根据此时node在屏幕上的情况，自动在以上几种mode中来回切换，并根据指定的参数范围来加载/释放资源，达到资源和性能的平衡。</p> <h2 id="小结"><a href="#小结" aria-hidden="true" class="header-anchor">#</a> 小结</h2> <p>由于Texture的基本理念是在需要创建UIView时替换成对应的Node来获取性能提升，因此对于现有代码改动较大，侵入性较高，同时由于大量原本熟悉的操作变成了异步的，对于一个团队来说学习曲线也较为陡峭。</p> <p>从我们在实际项目中的经验，结合Scott的建议来看，不需要也不可能将所有UIView都替换成其Node版本。将注意力集中在可能造成主线程阻塞的地方，如tableView/collectionView、复杂布局的View、使用连续手势的操作等等。找到合适的切入点将一部分性能需求较高的代码替换成Texture，会是一个较好的选择。</p></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/source/summary/Texture-note.html" class="prev">
          Texture 开发笔记
        </a></span> <span class="next"><a href="/source/summary/Texture-official-concept.html">
          Texture 基本概念
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/assets/js/app.645de36e.js" defer></script><script src="/assets/js/25.584ca57e.js" defer></script>
  </body>
</html>
