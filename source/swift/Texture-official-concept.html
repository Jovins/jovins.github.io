<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Texture 基本概念 | Jovins Blog</title>
    <meta name="description" content="Work Hard, Play Hard">
    <link rel="icon" href="/favicon.ico">
  <meta name="theme-color" content="#3eaf7c">
  <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/assets/css/0.styles.fa6af71c.css" as="style"><link rel="preload" href="/assets/js/app.f7cda7dc.js" as="script"><link rel="preload" href="/assets/js/14.05c65f0c.js" as="script"><link rel="prefetch" href="/assets/js/10.99bbcf46.js"><link rel="prefetch" href="/assets/js/100.8d269315.js"><link rel="prefetch" href="/assets/js/101.2e004423.js"><link rel="prefetch" href="/assets/js/102.dd5a6d67.js"><link rel="prefetch" href="/assets/js/103.0930fc18.js"><link rel="prefetch" href="/assets/js/11.6995aa03.js"><link rel="prefetch" href="/assets/js/12.d1aeb970.js"><link rel="prefetch" href="/assets/js/13.3808cbb9.js"><link rel="prefetch" href="/assets/js/15.8210a4e7.js"><link rel="prefetch" href="/assets/js/16.dd637c2e.js"><link rel="prefetch" href="/assets/js/17.1bac9075.js"><link rel="prefetch" href="/assets/js/18.a60404ed.js"><link rel="prefetch" href="/assets/js/19.5029f548.js"><link rel="prefetch" href="/assets/js/2.3b324bd1.js"><link rel="prefetch" href="/assets/js/20.71aeb006.js"><link rel="prefetch" href="/assets/js/21.49d3534c.js"><link rel="prefetch" href="/assets/js/22.28c254f2.js"><link rel="prefetch" href="/assets/js/23.55c74fb4.js"><link rel="prefetch" href="/assets/js/24.ce688c11.js"><link rel="prefetch" href="/assets/js/25.92ac2101.js"><link rel="prefetch" href="/assets/js/26.d144c623.js"><link rel="prefetch" href="/assets/js/27.dbc07e6f.js"><link rel="prefetch" href="/assets/js/28.72e03149.js"><link rel="prefetch" href="/assets/js/29.9f1f46fe.js"><link rel="prefetch" href="/assets/js/3.8e2386c4.js"><link rel="prefetch" href="/assets/js/30.ecfcb095.js"><link rel="prefetch" href="/assets/js/31.e00708c5.js"><link rel="prefetch" href="/assets/js/32.e66cde85.js"><link rel="prefetch" href="/assets/js/33.17b34f1f.js"><link rel="prefetch" href="/assets/js/34.ba2e8263.js"><link rel="prefetch" href="/assets/js/35.a35b2bf9.js"><link rel="prefetch" href="/assets/js/36.0f8ee978.js"><link rel="prefetch" href="/assets/js/37.9631b873.js"><link rel="prefetch" href="/assets/js/38.83917b50.js"><link rel="prefetch" href="/assets/js/39.5eb3b0f7.js"><link rel="prefetch" href="/assets/js/4.8c89249f.js"><link rel="prefetch" href="/assets/js/40.6577bc48.js"><link rel="prefetch" href="/assets/js/41.03d32368.js"><link rel="prefetch" href="/assets/js/42.285f334f.js"><link rel="prefetch" href="/assets/js/43.0dbac324.js"><link rel="prefetch" href="/assets/js/44.516aa197.js"><link rel="prefetch" href="/assets/js/45.f8b2e75e.js"><link rel="prefetch" href="/assets/js/46.57e9fe18.js"><link rel="prefetch" href="/assets/js/47.b165fdb0.js"><link rel="prefetch" href="/assets/js/48.aa65e477.js"><link rel="prefetch" href="/assets/js/49.ef99c175.js"><link rel="prefetch" href="/assets/js/5.20de59e0.js"><link rel="prefetch" href="/assets/js/50.dbeb44bd.js"><link rel="prefetch" href="/assets/js/51.5e2171f9.js"><link rel="prefetch" href="/assets/js/52.7634b21e.js"><link rel="prefetch" href="/assets/js/53.7bd0a528.js"><link rel="prefetch" href="/assets/js/54.01408fa6.js"><link rel="prefetch" href="/assets/js/55.e5207e84.js"><link rel="prefetch" href="/assets/js/56.58dc7dc8.js"><link rel="prefetch" href="/assets/js/57.807d5ae4.js"><link rel="prefetch" href="/assets/js/58.c4c79d2d.js"><link rel="prefetch" href="/assets/js/59.6642f800.js"><link rel="prefetch" href="/assets/js/6.b9dd5642.js"><link rel="prefetch" href="/assets/js/60.6b7b9dd4.js"><link rel="prefetch" href="/assets/js/61.5aeeb802.js"><link rel="prefetch" href="/assets/js/62.9cdb5886.js"><link rel="prefetch" href="/assets/js/63.afdbcf9a.js"><link rel="prefetch" href="/assets/js/64.4feec3f4.js"><link rel="prefetch" href="/assets/js/65.01ba651f.js"><link rel="prefetch" href="/assets/js/66.056b66d4.js"><link rel="prefetch" href="/assets/js/67.c2c8c5bf.js"><link rel="prefetch" href="/assets/js/68.6b9a7204.js"><link rel="prefetch" href="/assets/js/69.a20a5f13.js"><link rel="prefetch" href="/assets/js/7.919dc9ca.js"><link rel="prefetch" href="/assets/js/70.1931c188.js"><link rel="prefetch" href="/assets/js/71.57fb23ee.js"><link rel="prefetch" href="/assets/js/72.8372585b.js"><link rel="prefetch" href="/assets/js/73.090b450b.js"><link rel="prefetch" href="/assets/js/74.1f2a6bf8.js"><link rel="prefetch" href="/assets/js/75.4fd94b1a.js"><link rel="prefetch" href="/assets/js/76.b8670ce9.js"><link rel="prefetch" href="/assets/js/77.071bdc59.js"><link rel="prefetch" href="/assets/js/78.befd2888.js"><link rel="prefetch" href="/assets/js/79.ae9bdbfb.js"><link rel="prefetch" href="/assets/js/8.5bd05e3a.js"><link rel="prefetch" href="/assets/js/80.efecfca0.js"><link rel="prefetch" href="/assets/js/81.58171b2c.js"><link rel="prefetch" href="/assets/js/82.0308dcb2.js"><link rel="prefetch" href="/assets/js/83.d0b23df5.js"><link rel="prefetch" href="/assets/js/84.70b15320.js"><link rel="prefetch" href="/assets/js/85.b0f15c7e.js"><link rel="prefetch" href="/assets/js/86.842cbc20.js"><link rel="prefetch" href="/assets/js/87.78626080.js"><link rel="prefetch" href="/assets/js/88.74b57552.js"><link rel="prefetch" href="/assets/js/89.d6bbb9ba.js"><link rel="prefetch" href="/assets/js/9.4a615f07.js"><link rel="prefetch" href="/assets/js/90.e3526e1d.js"><link rel="prefetch" href="/assets/js/91.56e0a0b6.js"><link rel="prefetch" href="/assets/js/92.ecf957b4.js"><link rel="prefetch" href="/assets/js/93.5e7580df.js"><link rel="prefetch" href="/assets/js/94.a311b382.js"><link rel="prefetch" href="/assets/js/95.efcff5d2.js"><link rel="prefetch" href="/assets/js/96.0b29e685.js"><link rel="prefetch" href="/assets/js/97.52744029.js"><link rel="prefetch" href="/assets/js/98.2b890125.js"><link rel="prefetch" href="/assets/js/99.85ff620d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.fa6af71c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Jovins Blog</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/source/swift/" class="nav-link router-link-active">Swift</a></div><div class="nav-item"><a href="/source/go/" class="nav-link">Go</a></div><div class="nav-item"><a href="/source/program/" class="nav-link">小程序</a></div><div class="nav-item"><a href="/source/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/source/git/" class="nav-link">Git</a></div><div class="nav-item"><a href="https://github.com/Jovins" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/source/swift/" class="nav-link router-link-active">Swift</a></div><div class="nav-item"><a href="/source/go/" class="nav-link">Go</a></div><div class="nav-item"><a href="/source/program/" class="nav-link">小程序</a></div><div class="nav-item"><a href="/source/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/source/git/" class="nav-link">Git</a></div><div class="nav-item"><a href="https://github.com/Jovins" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading open"><span>技术文章</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/source/swift/Texture-note.html" class="sidebar-link">Texture 开发笔记</a></li><li><a href="/source/swift/Texture-why.html" class="sidebar-link">为什么使用Texture</a></li><li><a href="/source/swift/Texture-official-concept.html" class="active sidebar-link">Texture 基本概念</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/source/swift/Texture-official-concept.html#开始使用-texture" class="sidebar-link">开始使用 Texture</a></li><li class="sidebar-sub-header"><a href="/source/swift/Texture-official-concept.html#节点-node" class="sidebar-link">节点/Node</a></li><li class="sidebar-sub-header"><a href="/source/swift/Texture-official-concept.html#布局引擎-layout-engine" class="sidebar-link">布局引擎/Layout Engine</a></li><li class="sidebar-sub-header"><a href="/source/swift/Texture-official-concept.html#资源" class="sidebar-link">资源</a></li><li class="sidebar-sub-header"><a href="/source/swift/Texture-official-concept.html#安装-texture" class="sidebar-link">安装 Texture</a></li><li class="sidebar-sub-header"><a href="/source/swift/Texture-official-concept.html#升级到-2-0" class="sidebar-link">升级到 2.0</a></li><li class="sidebar-sub-header"><a href="/source/swift/Texture-official-concept.html#智能预加载" class="sidebar-link">智能预加载</a></li><li class="sidebar-sub-header"><a href="/source/swift/Texture-official-concept.html#节点容器-node-containers" class="sidebar-link">节点容器/Node Containers</a></li><li class="sidebar-sub-header"><a href="/source/swift/Texture-official-concept.html#节点子类-node-subclasses" class="sidebar-link">节点子类/Node Subclasses</a></li><li class="sidebar-sub-header"><a href="/source/swift/Texture-official-concept.html#asviewcontroller" class="sidebar-link">ASViewController</a></li></ul></li><li><a href="/source/swift/Texture-official-layout.html" class="sidebar-link">Texture 布局</a></li><li><a href="/source/swift/UIScrollView-touch-conflict.html" class="sidebar-link">UIScrollView嵌套滚动解决手势冲突</a></li><li><a href="/source/swift/Reading-List.html" class="sidebar-link">Reading List</a></li><li><a href="/source/swift/2018-reporter.html" class="sidebar-link">2018-小记</a></li><li><a href="/source/swift/iOS-Memory-explore.html" class="sidebar-link">iOS内存管理探究</a></li><li><a href="/source/swift/fastlane-auto-dev.html" class="sidebar-link">fastlane自动化开发组件</a></li><li><a href="/source/swift/dev-component.html" class="sidebar-link">组件化开发之开发小组件</a></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Swift 文章</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>OpenGL/OpenGL ES</span> <span class="arrow right"></span></p> <!----></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="texture-基本概念"><a href="#texture-基本概念" aria-hidden="true" class="header-anchor">#</a> Texture 基本概念</h1> <p><img src="/assets/img/NestedScrolling-00.4046a746.png" alt></p> <p><a href="https://github.com/TextureGroup/Texture" target="_blank" rel="noopener noreferrer">Texture<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="http://texturegroup.org/docs/getting-started.html" target="_blank" rel="noopener noreferrer">Texture文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="开始使用-texture"><a href="#开始使用-texture" aria-hidden="true" class="header-anchor">#</a> 开始使用 Texture</h2> <p>Texture 的基本单位是 <code>Node</code>，<code>ASDisplayNode</code> 是 <code>UIView</code> 和 <code>CALayer</code> 的抽象，它与 <code>UIKit</code> 的不同在于：</p> <p><code>Node</code> 可以异步绘制，且线程安全，你可以在在异步线程中进行实例化和配置它们的层级结构。</p> <p>为了保持用户界面的流畅，你的 App 应该以 1/60 秒的帧率呈现， 这意味着主线程有 1/ 60 秒来处理一帧，也就是说，主线程需要在 16 毫秒内来执行所有的布局和绘图代码，而由于一些系统级别的开销，你的布局绘图代码一般执行超过 10 毫秒，就可能引起掉帧。</p> <p><code>Texture</code> 可以让你将图像解码、文本渲染和其他消耗性能的 UI 操作从主线程剥离，以保证主线程可以流畅的响应用户的交互，<code>Texture</code> 还有其他的使用窍门，我们稍后会讲到。</p> <h2 id="节点-node"><a href="#节点-node" aria-hidden="true" class="header-anchor">#</a> 节点/Node</h2> <p><code>Node</code> 的用法跟 <code>UIView</code> 类似，且 <code>Node</code> 提供了 <code>UIView</code> 和 <code>CALayer</code> 属性。
Texture 提供了丰富的 Node 子类 ，用于取代 UIKit 组建。</p> <ul><li>ASDipslayNode -&gt; UIView</li> <li>ASCellNode -&gt; UITableViewCell/UICollectionViewCell</li> <li>ASScrollNode -&gt; UIScrollView</li> <li>ASEditableTextNode -&gt; UITextView</li> <li>ASTextNode, ASTextNode2 -&gt; UILabel</li> <li>ASImageNode, ASNetworkImageNode, ASMultiplexImageNode -&gt; UIImageView</li> <li>ASVideoNode -&gt; AVPlayerLayer</li> <li>ASVideoPlayerNode -&gt; UIMoviePlayer</li> <li>ASControlNode -&gt; UIControl</li> <li>ASButtonNode -&gt; UIButton</li> <li>ASMapNode -&gt; MKMapView</li></ul> <p>ASDipslayNode示意图:</p> <p><img src="/assets/img/ASDipslayNode.fe81827e.png" alt="ASDipslayNode"></p> <p>如果你会使用 <code>UIView</code>，那么你就已经知道如何使用 <code>Node</code> 了，<code>UIView</code> 中绝大部分的方法 <code>Node</code> 都有映射，并且 <code>UIView</code> 和 <code>CALayer</code> 大多数的属性，也是可以使用的。当属性和方法的命名有差异时，例如 <code>.clipsToBounds</code> 和 <code>.masksToBounds</code>，<code>Node</code> 默认使用 <code>UIView</code> 的命名，唯一例外的是 <code>Node</code> 使用 <code>.position</code> 替代了 <code>.center</code>。</p> <p>当然，你也可以通过 <code>node.view</code> 或 <code>node.layer</code> 直接调用原生属性和方法，但要确保它会在主线程上执行！</p> <p>Texture 已经提供了多种多样的 <code>Node</code> 来替换你习惯使用的大部分 UIKit 组件，现在你已经可以完全通过 Texture 开发大规模的 App 。</p> <p>##节点容器/Node Containers</p> <p>推荐使用 Node Container 来包含 Nodes，Texture 提供以下 Node Containers：</p> <ul><li>ASCollectionNode -&gt; UICollectionView</li> <li>ASPagerNode -&gt; UIPageViewController</li> <li>ASTableNode -&gt; UITableView</li> <li>ASViewController -&gt; UIViewController</li> <li>ASNavigationController -&gt; UINavigationController</li> <li>ASTabBarController -&gt; UITabBarController</li></ul> <p>Node Containers 好处都有啥？
智能预加载。这意味所有 Node 相关的布局计算，数据获取，解码和渲染都可以异步完成。</p> <p>当你将 Texture 集成到一个项目中时，一个常见的错误是将 <code>Node</code> 直接添加到已有的视图中，这样做的结果是你的节点在渲染时会闪烁。</p> <p>正确的做法是，你应该把节点添加到 Node 容器中，由 Node 容器负责管理这些节点，你可以把 Node 容器理解为 UIKit 和 ASDK 之间的桥梁。</p> <h2 id="布局引擎-layout-engine"><a href="#布局引擎-layout-engine" aria-hidden="true" class="header-anchor">#</a> 布局引擎/Layout Engine</h2> <p>Texture 的布局非常强大，相对于传统的 Frame，AutoLayout 等方式而言比较独特，但对前端工作者并不陌生，Texture 的布局基于 CSS FlexBox。它提供了指定自定义节点的大小和其子节点布局的声明方式，当所有的节点同时被渲染时，通过为每个节点提供的 <code>ASLayoutSpec</code> 异步计算 size 和布局。</p> <p><strong>高级开发者功能</strong></p> <p>Texture 提供了在 UIKit 或 Foundation 中无法找到的各种高级开发功能，我们的开发人员发现，Texture 可以简化它们的架构，从而提高了开发效率。</p> <p><strong>集成 Texture</strong></p> <p>如果你第一次使用 Texture，我们建议你看看 ASDKgram 示例，我们已经撰写了一个 Guide（即将推出），指导你如何一步一步将 Texture 集成到一个 App 中。</p> <p>如果您遇到任何问题，请到我们的 GitHub 或 <a href="http://texturegroup.org/docs/resources.html" target="_blank" rel="noopener noreferrer">Slack<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>寻求帮助。</p> <h2 id="资源"><a href="#资源" aria-hidden="true" class="header-anchor">#</a> 资源</h2> <p>在 Slack 社区，和 Texture 的核心团队及 700+ Texture 开发者一起，实时 Debug、获取更新和进行交流，<a href="http://texturegroup.org/slack.html" target="_blank" rel="noopener noreferrer">点此注册<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p><strong>示例</strong></p> <p>查看我们的<a href="https://github.com/texturegroup/texture/tree/master/examples" target="_blank" rel="noopener noreferrer">示例库<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，如果你第一次使用 Texture，我们建议你从 <a href="https://github.com/texturegroup/texture/tree/master/examples/ASDKgram" target="_blank" rel="noopener noreferrer">ASDKgram<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 开始，这个示例同时使用 UIKit 和 Texture 实现了照片Feed，你可以对比查看它们的区别，它的特点是：</p> <ol><li>一个无限滚动的 Home Feed，演示 Texture 的平滑滚动性能；</li> <li>一个相当庞大的代码库，用于演示使用 Texture 设计 App 可以减少多少代码；</li></ol> <p><strong>FlexBox 布局学习</strong></p> <p>Texture 强大的布局系统基于CSS FlexBox 模型，这些网站对于学习 FlexBox 的基本知识非常有用。</p> <ul><li><a href="https://huynguyen.dev/froggy-asdk-layout/" target="_blank" rel="noopener noreferrer">ASStackLayout Game<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://demos.scotch.io/visual-guide-to-css3-flexbox-flexbox-playground/demos/" target="_blank" rel="noopener noreferrer">Visual Guide to CSS3 Flexbox<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://www.flexboxpatterns.com/" target="_blank" rel="noopener noreferrer">FlexBox Patterns<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h2 id="安装-texture"><a href="#安装-texture" aria-hidden="true" class="header-anchor">#</a> 安装 Texture</h2> <p>Texture 可以使用 CocoaPods 和 Carthage 安装，使用时不要忘记导入头文件：</p> <div class="language-objective-c extra-class"><pre class="language-text"><code>#import &lt;AsyncDisplayKit/AsyncDisplayKit.h&gt;
</code></pre></div><p>如果你使用 Swift 开发，可以使用 Objective-C bridging header 进行桥接，如果你在安装中遇到任何问题，请在 GitHub 或 <a href="https://link.juejin.im?target=http%3A%2F%2Ftexturegroup.org%2Fslack.html" target="_blank" rel="noopener noreferrer">Slack<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 联系我们。</p> <p><strong>CocoaPods</strong></p> <p>使用 CocoaPods 安装，将以下内容添加到 Podfile：</p> <div class="language- extra-class"><pre class="language-text"><code>target 'MyApp' do
    pod &quot;Texture&quot;
end
</code></pre></div><p>完全退出 Xcode，打开终端，cd 到项目目录，执行下面的命令：</p> <div class="language- extra-class"><pre class="language-text"><code>pod install
</code></pre></div><p>如果要更新 Texture，打开终端，cd 到项目目录，执行下面的命令：</p> <div class="language- extra-class"><pre class="language-text"><code>pod update Texture
</code></pre></div><p>不要忘记使用 <code>.xcworkspace</code> 打开，而不是 <code>.xcodeproj</code>。</p> <p><strong>Carthage</strong></p> <blockquote><p>使用迦太基需要创建一个Cartfile 列表，然后执行 <code>carthage update</code>，将依赖项下载到 <code>Cathage/Checkouts</code> 文件夹中，并将它们构建到位于 <code>Carthage/Build</code> 文件夹中，开发人员须手工集成到项目中。</p></blockquote> <p>Texture 也可以通过迦太基安装，将以下内容添加到 Cartfile 以获取最新的 release 版本：</p> <div class="language- extra-class"><pre class="language-text"><code>github &quot;texturegroup/texture&quot;
</code></pre></div><p>或者获取主干：</p> <div class="language- extra-class"><pre class="language-text"><code>github &quot;texturegroup/texture&quot; &quot;master&quot;
</code></pre></div><p>Texture 有自己的 Cartfile，指明了自己的依赖项，Texture 所需的依赖会自动安装，安装 Texture 依赖需要使用终端，在Carthage/Checkouts 目录下，执行：</p> <div class="language- extra-class"><pre class="language-text"><code>carthage update
</code></pre></div><p>确认 Texture、PINRemoteImage (3.0.0-beta.2)、PINCache 全部获取和构建，Texture 的 Cartfile 会自动处理这些依赖关系。</p> <p>打开 Xcode，将所需的框架拖到 <code>TARGETS - General -Linked Frameworks and Libraries</code>。</p> <p><strong>Carthage(light)</strong></p> <p>Texture 不支持 Carthage 更轻量的使用方式，你需要手动添加项目文件， 这是因为 Texture 的依赖 PINCache 还没有项目文件，</p> <blockquote><p>PINCache 是 PINRemoteImage 一个嵌套的依赖。</p></blockquote> <p>如果没有 PINRemoteImage 和 PINCache，你将无法完整的使用 Texture 图像功能集。</p> <h2 id="升级到-2-0"><a href="#升级到-2-0" aria-hidden="true" class="header-anchor">#</a> 升级到 2.0</h2> <p><strong>发布说明</strong></p> <p>请阅读 GitHub 上的官方发布说明。</p> <p><strong>获取正式候选版本</strong></p> <p>将以下内容添加到你的 pod 文件中：</p> <div class="language- extra-class"><pre class="language-text"><code>pod 'Texture', '&gt;= 2.0'
</code></pre></div><p>在终端执行：</p> <div class="language- extra-class"><pre class="language-text"><code>pod repo update
pod update Texture
</code></pre></div><p><strong>测试 2.0</strong></p> <p>一旦你更新到2.0，你会看到许多弃用警告。 别担心！这些警告是安全的，因为我们已经桥接了所有旧的 API，以便在迁移到新的 API 之前对 2.0 进行测试。
如果你的 App 无法构建成功而不是仅显示警告，那么你的项目中可能出现错误，你有几个选择：</p> <ol><li>在 project settings 中禁用 deprecation warnings；</li> <li>在项目的 build settings 中禁用 warnings as errors；</li> <li>在 Texture 中禁用 deprecation warnings，这需要你将 <code>ASBaseDefines.h</code> 中的第 74 行更改为 <code># define ASDISPLAYNODE_WARN_DEPRECATED 0</code></li></ol> <p>当你的 App 构建成功并运行，你需要测试它以确保一切正常工作。 如果你发现任何问题，请尝试在该区域采用新的 API 并重新测试。</p> <p>你可能会注意到一个关键的变化：</p> <p><code>ASStackLayoutSpec的.alignItems</code> 属性默认值更改为 <code>ASStackLayoutAlignItemsStretch</code> 而不是 <code>ASStackLayoutAlignItemsStart</code>，这可能会在 UI 中造成失真。</p> <p>如果还有其他问题，请提交 GitHub issue，我们很乐意帮助你！</p> <h2 id="智能预加载"><a href="#智能预加载" aria-hidden="true" class="header-anchor">#</a> 智能预加载</h2> <p>异步并发渲染和 FlexBox 布局已经非常强大，但 Texture 做到的不止于此，另外一个重要的层面是智能预加载的思想。</p> <p>正如在开始使用 Texture 这节中讲的那样，在一个节点容器的上下文之外使用一个节点有一些弊端的。这是因为所有的节点都具有当前界面状态的概念，这个状态命名为 <code>interfaceState</code>。</p> <p><code>interfaceState</code> 这个属性是不断更新的，它的更新由 <code>ASRangeController</code> 所控制，<code>ASRangeController</code> 又由所有的节点容器在内部创建和维护。</p> <p>在容器外部使用的节点不会被 <code>ASRangeController</code> 更新状态，因此这有时会导致闪烁，原因是这些容器外的节点因为状态的错误，在节点被渲染到屏幕后又进行了一次渲染。</p> <p><strong>Interface State Ranges</strong></p> <p>当将节点添加到滚动或分页界面时，它们通常位于以下范围中的一个。这意味着当滚动视图被滚动时，它们的界面状态将随着它们的移动而更新。</p> <p><img src="/assets/img/texture-concept-01.f6e69902.png" alt>)</p> <p>一个节点的所处的范围会是以下范围中的一个：</p> <table><thead><tr><th>界面范围</th> <th>描述</th></tr></thead> <tbody><tr><td>Preload</td> <td>节点还不可见，这时节点收集外部源，外部源可能是 API 或者本地磁盘。</td></tr> <tr><td>Display</td> <td>节点开始渲染，包括文本的光栅化已经图像解码等。</td></tr> <tr><td>Visible</td> <td>节点可见，在屏幕上至少拥有一个像素。</td></tr></tbody></table> <p><strong>ASRangeTuningParameters</strong></p> <p>每个范围的大小以整个屏幕的尺寸作为参照， 默认的 size 在许多用例中都能很好地工作，你也可以通过在滚动节点上设置范围参数来调整它们。</p> <p><img src="/assets/img/texture-concept-02.db23357b.png" alt="img"></p> <p>在上面的一个滚动集合的示例图片中，用户正在向下滚动。正如你所看到的，用户滚动方向区域（领先方向）要比用户离开方向区域（尾随方向）大得多。为了保持内存的最佳使用，当用户改变滚动方向时，两个区域会动态地交换。这使你不必考虑滚动方向的变化，只需关注领先方向和尾随方向的区域大小。</p> <p>在这张图中，你可以看到智能的预加载是如何进行工作的，你可以看到在一个垂直的滚动容器中，虽然有些节点还未在设备屏幕中出现，但是它有一个范围控制器，屏幕外的节点处在 Preload 数据准备范围和 Display 渲染准备范围。</p> <p><strong>Interface State Callbacks</strong></p> <p>当用户滚动时，节点在这三个范围中切换，并通过加载数据，渲染等作出适当的反应。你创建的节点子类可以通过实现相应的回调方法进入此机制。</p> <div class="language-swift extra-class"><pre class="language-swift"><code><span class="token keyword">class</span> <span class="token class-name">TZYNode</span><span class="token punctuation">:</span> <span class="token builtin">ASDisplayNode</span> <span class="token punctuation">{</span>

    <span class="token keyword">override</span> <span class="token keyword">func</span> <span class="token function">didEnterPreloadState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;进入数据加载范围&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">override</span> <span class="token keyword">func</span> <span class="token function">didExitPreloadState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;离开数据加载范围&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">override</span> <span class="token keyword">func</span> <span class="token function">didEnterDisplayState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;进入渲染范围&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">override</span> <span class="token keyword">func</span> <span class="token function">didExitDisplayState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;离开渲染范围&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">override</span> <span class="token keyword">func</span> <span class="token function">didEnterVisibleState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;进入可见范围&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">override</span> <span class="token keyword">func</span> <span class="token function">didExitVisibleState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;离开可见范围&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="节点容器-node-containers"><a href="#节点容器-node-containers" aria-hidden="true" class="header-anchor">#</a> 节点容器/Node Containers</h2> <p><strong>在节点容器中使用节点</strong></p> <p>我们强烈建议你在节点容器中使用 Texture 的节点， Texture 提供以下节点容器：</p> <table><thead><tr><th>节点容器</th> <th>等价于 UIKit</th></tr></thead> <tbody><tr><td>ASCollectionNode</td> <td>代替 UICollectionView</td></tr> <tr><td>ASPagerNode</td> <td>代替UIPageViewController</td></tr> <tr><td>ASTableNode</td> <td>代替UITableView</td></tr> <tr><td>ASViewController</td> <td>代替UIViewController</td></tr> <tr><td>ASNavigationController</td> <td>代替UINavigationController，实现 ASVisibility 协议。</td></tr> <tr><td>ASTabBarController</td> <td>代替UITabBarController，实现 ASVisibility 协议。</td></tr></tbody></table> <p>示例代码和特定示例项目会在每个节点容器的文档中突出显示。</p> <p><strong>为什么使用节点容器</strong></p> <p>节点容器自动管理其子节点实现智能预加载，这意味着节点的所有布局计算，数据读取，解码和渲染都将会异步完成，这就是为什么我们建议将节点放进节点容器中使用的原因。
请注意，尽管你可以直接使用节点而不加入节点容器，但除非你添加其他回调，否则这个容器外的节点只会在屏幕出现时才会开始渲染。如同 UIKit 所做的那样，这可能导致性能下降和内容闪烁。</p> <h2 id="节点子类-node-subclasses"><a href="#节点子类-node-subclasses" aria-hidden="true" class="header-anchor">#</a> 节点子类/Node Subclasses</h2> <p>在 UIKit 组件上使用节点的一个主要优点是，所有的节点都预先在主线程布局并绘制，这样主线程就可以立即响应用户交互事件，而无需先处理控件的渲染，Texture 提供以下节点：</p> <table><thead><tr><th>节点</th> <th>等价于 UIKit</th></tr></thead> <tbody><tr><td>ASDisplayNode</td> <td>代替 UIView，所有的 Node 都继承自 ASDisplayNode。</td></tr> <tr><td>ASCellNode</td> <td>代替 UITableViewCell＆UICollectionViewCell，需要和 ASTableNode，ASCollectionNode 和 ASPagerNode 共同使用。</td></tr> <tr><td>ASScrollNode</td> <td>代替 UIScrollView，这个节点对于创建自定义的，包含其他节点的可滚动区域非常有用。</td></tr> <tr><td>ASEditableTextNode</td> <td>代替 UITextView。</td></tr> <tr><td>ASTextNode</td> <td>代替 UILabel。</td></tr> <tr><td>ASImageNode</td> <td>代替 UIImage。</td></tr> <tr><td>ASNetworkImageNode</td> <td>代替 UIImage。</td></tr> <tr><td>ASMultiplexImageNode</td> <td>代替 UIImage。</td></tr> <tr><td>ASVideoNode</td> <td>代替 AVPlayerLayer。</td></tr> <tr><td>ASVideoPlayerNode</td> <td>代替 UIMoviePlayer。</td></tr> <tr><td>ASControlNode</td> <td>代替 UIControl。</td></tr> <tr><td>ASButtonNode</td> <td>代替 UIButton。</td></tr> <tr><td>ASMapNode</td> <td>代替 MKMapView。</td></tr></tbody></table> <p>尽管与 UIKit 组件大致相当，但一般而言，Texture 节点提供了更高级的功能和便利。 例如，<code>ASNetworkImageNode</code> 可以自动加载网络图片和进行缓存管理，甚至支持渐进式 JPEG 和动画 GIF。</p> <p><a href="https://github.com/texturegroup/texture/tree/master/examples/AsyncDisplayKitOverview" target="_blank" rel="noopener noreferrer">AsyncDisplayKitOverview <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>示例应用程序给出了上面列出的每个节点的基本实现。</p> <p><strong>节点继承关系/Node Inheritance Hierarchy</strong></p> <p>所有的 Texture 节点都继承自 <code>ASDisplayNode</code>。</p> <p><img src="/assets/img/texture-concept-03.8dda3668.png" alt="Node层级"></p> <blockquote><p>原图使用花体英文，<a href="http://texturegroup.org/static/images/node-hierarchy.png" target="_blank" rel="noopener noreferrer">查看原图<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p></blockquote> <p>右侧的节点是 UIKit 元素的封装。 例如，<code>ASScrollNode</code> 封装了一个 <code>UIScrollView</code>，而 <code>ASCollectionNode</code> 封装了一个 <code>UICollectionView</code>。 <code>liveMapMode</code> 中的 <code>ASMapNode</code> 是 <code>UIMapView</code> 的封装。</p> <blockquote><p>liveMapMode 未在此节和之前章节出现，不清楚是否为笔误。</p></blockquote> <p>##节点实例/Subclassing</p> <p>创建子类时最重要的区别是你使用的是 <code>ASViewController</code> 还是  <code>ASDisplayNode</code>，这听起来很明显，但是因为这其中有一些微妙的差异，所以记住这点还是相当重要的。</p> <p><strong>ASDisplayNode</strong></p> <p>虽然实例化节点与 <code>UIView</code> 类似，但需要遵循一些原则，以确保你充分利用了它的能力，并确保节点按照预期的方式运行。</p> <p><strong>-init</strong></p> <p>在使用 <code>initNodeBlocks</code> 时，这个方法会后台线程上被调用。但是，因为没有其他方法会在 <code>init</code> 完成之前运行，所以这个方法不需要加锁。</p> <p>需要记住的最重要的一点是，<code>init</code> 方法必须能够在任何队列上调用。最值得注意的是，你永远不应该在节点初始化方法中初始化任何 UIKit 对象，以及调用 <code>node.layer</code> <code>node.view.x</code> 等与<code>view</code> 或 <code>layer</code> 有关的操作，也不应该在这个方法中为节点添加手势，这些事件应该在 <code>didLoad</code> 方法中进行。</p> <p><strong>-didLoad</strong></p> <p>这个方法在概念上类似于 <code>UIViewController</code> 的 <code>-viewDidLoad</code> 方法，当后台视图初始化完成时，它会被调用一次，它保证会在主线程上被调用，是执行任何 UIKit 代码合适的地方，例如添加手势识，更改 <code>view</code> 和 <code>layer</code>，初始化 UIKit 对象。</p> <p><strong>-layoutSpecThatFits:</strong></p> <p>该方法定义了节点的布局，并在后台线程上进行了大量的计算。此方法是你声明、创建和修改 <code>ASLayoutSpec</code> 布局描述对象的地方，该对象描述了节点的 size，以及其子节点的 size 和 position，是你放置大部分布局代码的地方。</p> <p><code>ASLayoutSpec</code> 对象直到在此方法中返回前是可变的。 在这之后，这个对象将不可改变，需要注意的是你不需要缓存 <code>ASLayoutSpec</code>  对象以备后用，我们建议你在必要时重新创建布局描述。</p> <p>由于它在后台线程上运行，因此你不能在这个方法中调用 <code>node.view</code> 或 <code>node.layer</code> 以及它们的属性。 此外，除非你明确知道自己在做什么，否则不要在此方法中创建其他节点。 另外，重写此方法并不一定需要调用 <code>super</code> 方法。</p> <p><strong>-layout</strong></p> <p>在此方法中调用 <code>super</code> 将，会使用  <code>layoutSpec</code> 对象计算布局，所有子节点都将计算其 size 和 position。</p> <p><code>-layout</code> 在概念上类似于 <code>UIViewController</code> 的 <code>-viewwilllayoutsubview</code>，这是一个更改 <code>hidden</code> 属性、修改 <code>view</code> 属性、设置背景颜色的好地方。你可以在 <code>-layoutspec:</code> 方法中设定背景颜色，但这可能会存在时序问题。如果你需要使用原生的 <code>UIView</code>，可以在这里设置它们的 <code>frame</code>，不管怎样，你始终可以使用 <code>-initWithViewBlock:</code> 创建节点，并在其他地方的后台线程中进行调整。</p> <p>这个方法在主线程上被调用，如果你使用的是 <code>ASLayoutSpec</code>，那么你不应该过多地依赖这个方法，因为在主线程上进行布局是非常可取的，需要这个方法的子类小于 1/10。</p> <p>使用 <code>-layout</code> 的一个重要用途是你需要子节点的 size 是精确的。举例来说，当你希望一个 <code>collectionNode</code> 可以铺面屏幕，这种情况不被 <code>ASLayoutSpec</code> 很好的支持，此时最简单的做法是在这个方法中手动设定 <code>frame</code>：</p> <div class="language- extra-class"><pre class="language-text"><code>subnode.frame = self.bounds
</code></pre></div><p>如果你希望在 <code>ASViewController</code> 中得到相同的效果，那么你可以在 <code>-viewWillLayoutSubviews</code> 中做同样的事情，不过如果你的节点通过 <code>initWithNode:</code> 进行实例化，它会自动做到这一点。</p> <h2 id="asviewcontroller"><a href="#asviewcontroller" aria-hidden="true" class="header-anchor">#</a> ASViewController</h2> <p><code>ASViewController</code> 是一个常规的 <code>UIViewController</code> 子类，它具有管理节点的特殊功能。因为它是一个 <code>UIViewController</code> 子类，所以所有的方法都在主线程上被调用，并且你应该在主线程上创建至少一个 <code>ASViewController</code>。</p> <p><strong>-init</strong></p> <p>这个方法在 <code>ASViewController</code> 的生命周期开始时被调用一次，与 <code>UIViewController</code> 的初始化一样，你最好不要在这个方法中访问 <code>self.view</code> 或  <code>self.node.view</code>，因为这样会强制创建 <code>view</code>。 这些操作可以在 <code>-viewDidLoad</code> 中进行，<code>-viewDidLoad</code> 可以执行任何 <code>view</code> 的访问。</p> <p><code>ASViewController</code> 指定的构造器是 <code>initWithNode:</code>，一个典型的构造器看起来就像下面的代码。请注意下面的代码，在调用 <code>super</code> 之前，<code>ASViewController</code> 的节点是如何被创建的，<code>ASViewController</code> 管理节点类似于 <code>UIViewController</code> 管理视图，但是它的初始化方式有所区别：</p> <div class="language-swift extra-class"><pre class="language-swift"><code><span class="token keyword">class</span> <span class="token class-name">TZYVC</span><span class="token punctuation">:</span> <span class="token builtin">ASViewController</span><span class="token operator">&lt;</span><span class="token builtin">ASDisplayNode</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>

    <span class="token keyword">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> pagerNode <span class="token operator">=</span> <span class="token function">ASPagerNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span>node<span class="token punctuation">:</span> pagerNode<span class="token punctuation">)</span>
        pagerNode<span class="token punctuation">.</span><span class="token function">setDataSource</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span>
        pagerNode<span class="token punctuation">.</span><span class="token function">setDelegate</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">required</span> <span class="token keyword">init</span><span class="token operator">?</span><span class="token punctuation">(</span>coder aDecoder<span class="token punctuation">:</span> <span class="token builtin">NSCoder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">fatalError</span><span class="token punctuation">(</span><span class="token string">&quot;init(coder:) has not been implemented&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">extension</span> <span class="token constant">TZYVC</span><span class="token punctuation">:</span> <span class="token builtin">ASPagerDataSource</span> <span class="token punctuation">{</span>

    <span class="token keyword">func</span> <span class="token function">numberOfPages</span><span class="token punctuation">(</span><span class="token keyword">in</span> pagerNode<span class="token punctuation">:</span> <span class="token builtin">ASPagerNode</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">Int</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">10</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">extension</span> <span class="token constant">TZYVC</span><span class="token punctuation">:</span> <span class="token builtin">ASPagerDelegate</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre></div><p><strong>-loadView</strong></p> <p>我们建议你不要使用这个方法，因为与 <code>-viewDidLoad</code> 相比，它没有什么特别的优势，并且有一些缺点。 但是，只要不将 <code>self.view</code> 属性设置为不同的值，它可以安全的使用。 它的 <code>super</code> 方法会将其封装的 <code>UIViewController</code> 的 <code>view</code> 设置为 <code>ASViewController</code> 的 <code>node.view</code>。</p> <p><strong>-viewDidLoad</strong></p> <p>这个方法在 <code>-loadView</code> 之后被执行，这是 <code>ASViewController</code> 生命周期中，你可以访问 <code>node.view</code> 最早的方法，你可以在这份方法中任意修改 <code>view</code> 和 <code>layer</code> 或添加手势，这个方法在其所属的生命周期中，只会执行一次。</p> <p>所以布局代码不应该放在这个方法中，因为当界面重绘时，这里的代码不会被再次调用。<code>UIViewController</code> 中这个方法也是同样的，在这种方法中放置布局代码是一种不太好的做法，即使你的布局不会因为交互发生变化。</p> <p><strong>-viewWillLayoutSubviews</strong></p> <p>这个方法会与节点的 <code>-layout</code> 同时调用，它可能在 <code>ASViewController</code> 的生命周期中被多次调用，当 <code>ASViewController</code> 的节点的边界发生改变，如旋转、分割屏幕、键盘弹出等行为，或者当视图的层次结构发生变化，如子节点添加、删除或改变大小时，这个方法将被调用。</p> <p>因为它不经常被调用，但是调用就代表页面需要重绘，因此所有的布局代码最好都放在这个方法中，即使是不直接依赖于 size 的 UI 代码也应放在这里。</p> <p><strong>-viewWillAppear: / -viewDidDisappear:</strong></p> <p><code>viewWillAppear</code> 在 <code>ASViewController</code> 的节点出现在屏幕上之前被调用，这是节点从屏幕出现的最早时间，<code>viewDidDisappear</code> 在控制器从视图层次结构中移除之后被调用，这是节点从屏幕消失的最早时机，这两个方法提供了一个很好的时机来启动或停止与控制器相关的动画，这也是一个保存和记录用户行为日志的好地方。</p> <p>尽管这些方法可能被多次调用，并且是可以执行布局代码的，但是这两个方法不会在所有需要重绘的时候被调用，因此除了特定的动画设置之外，不应该用于执行核心的布局代码。</p></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/source/swift/Texture-why.html" class="prev">
          为什么使用Texture
        </a></span> <span class="next"><a href="/source/swift/Texture-official-layout.html">
          Texture 布局
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/assets/js/app.f7cda7dc.js" defer></script><script src="/assets/js/14.05c65f0c.js" defer></script>
  </body>
</html>
