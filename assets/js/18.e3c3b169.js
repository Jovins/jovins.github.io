(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{333:function(e,t,i){e.exports=i.p+"assets/img/texture-why-01.aa159a32.png"},334:function(e,t,i){e.exports=i.p+"assets/img/texture-why-02.7069e5d1.png"},335:function(e,t,i){e.exports=i.p+"assets/img/texture-why-03.0d3f7451.png"},336:function(e,t,i){e.exports=i.p+"assets/img/texture-why-04.d85f7906.png"},432:function(e,t,i){"use strict";i.r(t);var a=[function(){var e=this.$createElement,t=this._self._c||e;return t("h1",{attrs:{id:"为什么使用texture"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用texture","aria-hidden":"true"}},[this._v("#")]),this._v(" 为什么使用Texture")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"原因"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原因","aria-hidden":"true"}},[this._v("#")]),this._v(" 原因")])},function(){var e=this.$createElement,t=this._self._c||e;return t("li",[t("p",[t("strong",[this._v("CPU(主要是主线程)/GPU负担过重或者不均衡")]),this._v("（诸如mask/cornerRadius/drawRect/opaque带来offscreen\nrendering/blending等等）。由于所有的UIView都是由CALayer来负责显示，因此对Core\nAnimation的了解就变得尤为重要。这里推荐Nick Lockwood的"),t("em",[this._v("Core Animation: AdvancedTechniques")]),this._v("一书，其中有对Core Animation的性能有着非常详尽的梳理和剖析。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("li",[t("p",[this._v("尽管从iPhone4S(A5)开始CPU已经采用多核，**然而对于大多数app来说，多线程协作并没有被充分利用。**换句话说，在app卡顿（主线程所占用的核心满负荷）时，往往CPU的其他核心几乎无事可做。一般情况下，由于主线程承担了绝大部分的工作，如果能把主线程的任务转移一部给其他线程进行异步处理，就可以马上享受到并发带来的性能提升。这应该也是AsyncDisplayKit得名的原因之一。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"优化思路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优化思路","aria-hidden":"true"}},[this._v("#")]),this._v(" 优化思路")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("img",{attrs:{src:i(333),alt:"img"}})])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("strong",[this._v("Texture的基本思路：异步")])])},function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("ol",[i("li",[i("strong",[e._v("渲染")]),e._v("，对于大量图片，或者大量文字（尤其是CJK字符）混合在一起时。而文字区域的大小和布局，恰恰依赖着渲染的结果。Texture尽可能后台线程进行渲染，完成后再同步回主线程相应的UIView。")]),e._v(" "),i("li",[i("strong",[e._v("布局")]),e._v("。Texture完全弃用了Autolayout，另辟蹊径实现了自己的布局和缓存机制。")]),e._v(" "),i("li",[e._v("系统objects的"),i("strong",[e._v("创建与销毁")]),e._v("。由于UIKit封装了CALayer以支持触摸等显示以外的操作，耗时也相应增加。而这些同样也需要在主线程上操作。Texture基于Node的设计，突破了UIKit线程的限制。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("img",{attrs:{src:i(334),alt:"img"}})])},function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("ul",[i("li",[i("p",[e._v("每个Node对应相应的UIView或者CALayer，从开发者的角度而言，只需要将初始化UIView的代码稍作修改，替换为创建ASDisplayNode即可。在不需要接受用户操作的Node上可以开启isLayerBacked，直接使用CALayer进一步降低开销。根据Scott的研究UIView的开销大约是CALayer的5倍。")])]),e._v(" "),i("li",[i("p",[e._v("Node默认是异步布局/渲染，只有在需要将frame/contents等同步到UIView上才会回到主线程，使其空出更多的时间处理其他事件。")])]),e._v(" "),i("li",[i("p",[e._v("Texture只有在认为需要的时候才会异步地为Node加载相应的View，因此创建Node的开销变得非常低。同时Node是线程安全的，可以在任意queue上创建和设置属性。")])]),e._v(" "),i("li",[i("p",[e._v("Texture不仅有与UIView对应的大部分控件（如ASButtonNode、ASTextNode、ASImageNode、ASTableNode等等），同时也bridge了大多数UIView的方法和属性，可以非常方便的操作frame/backgroundColor/addSubnode等，因此一般情况下只要对Node进行操作，Texture就会在适当的时候同步到其View。如果需要的话，当相应的View加载之后（或访问node.view手动触发加载），也可以通过node.view的方式直接访问，回到我们熟悉的UIKit。")])]),e._v(" "),i("li",[i("p",[e._v("当实现自定义View的时候，ASDisplayNode提供了一个初始化方法initWithViewBlock/initWithLayerBlock，就可以将任意UIView/CALayer用Node包裹起来（被包裹的view可以使用autolayout），从而与Texture的其他组件相结合。虽然这样创建的Node与一般view在布局和渲染上的差异不大，但是由于Node管理着何时何地加载view，我们仍然能得到一定的性能提升。")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language-objective-c extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v('_imageView = [[UIImageView alloc] init];\n_imageView.image = [UIImage imageNamed:@"hello"];\n_imageView.frame = CGRectMake(10.0f, 10.0f, 40.0f, 40.0f);\n[self.view addSubview:_imageView];\n')])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language-objective-c extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v('_imageNode = [[ASImageNode alloc] init];\n_imageNode.image = [UIImage imageNamed:@"hello"];\n_imageNode.frame = CGRectMake(10.0f, 10.0f, 40.0f, 40.0f);\n[self.view addSubview:_imageNode.view];\n')])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"texture注释"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#texture注释","aria-hidden":"true"}},[this._v("#")]),this._v(" Texture注释")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ol",[t("li",[this._v("在ASDisplayNode.h中有相当多的注释，其中displaysAsynchronously属性大致描述了异步渲染的步骤：")])])},function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("blockquote",[i("ul",[i("li",[e._v("Asynchronous rendering proceeds as follows:")]),e._v(" "),i("li",[e._v("When the view is initially added to the hierarchy, it has -needsDisplay true.")]),e._v(" "),i("li",[e._v("After layout, Core Animation will call -display on the _ASDisplayLayer")]),e._v(" "),i("li",[e._v("-display enqueues a rendering operation on the displayQueue")]),e._v(" "),i("li",[e._v("When the render block executes, it calls the delegate display method\n(-drawRect:… or -display)")]),e._v(" "),i("li",[e._v("The delegate provides contents via this method and an operation is added to\nthe asyncdisplaykit_async_transaction")]),e._v(" "),i("li",[e._v("Once all rendering is complete for the current\nasyncdisplaykit_async_transaction,")]),e._v(" "),i("li",[e._v("the completion for the block sets the contents on all of the layers in the\nsame frame")])])])},function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("blockquote",[i("p",[e._v("/**")]),e._v(" "),i("ul",[i("li",[e._v("@abstract Whether to draw all descendant nodes’ layers/views into this node’s\nlayer/view’s backing store.")]),e._v(" "),i("li",[e._v("@discussion")]),e._v(" "),i("li",[e._v("When set to YES, causes all descendant nodes’ layers/views to be drawn\ndirectly into this node’s layer/view’s backing")]),e._v(" "),i("li",[e._v("store. Defaults to NO.")]),e._v(" "),i("li",[e._v("If a node’s descendants are static (never animated or never change attributes\nafter creation) then that node is a")]),e._v(" "),i("li",[e._v("good candidate for rasterization. Rasterizing descendants has two main\nbenefits:")]),e._v(" "),i("li",[i("ol",[i("li",[e._v("Backing stores for descendant layers are not created. Instead the layers\nare drawn directly into the rasterized")])])]),e._v(" "),i("li",[e._v("container. This can save a great deal of memory.")]),e._v(" "),i("li",[i("ol",{attrs:{start:"2"}},[i("li",[e._v("Since the entire subtree is drawn into one backing store, compositing and\nblending are eliminated in that subtree")])])]),e._v(" "),i("li",[e._v("which can help improve animation/scrolling/etc performance.")]),e._v(" "),i("li",[e._v("Rasterization does not currently support descendants with transform,\nsublayerTransform, or alpha. Those properties")]),e._v(" "),i("li",[e._v("will be ignored when rasterizing descendants.")]),e._v(" "),i("li",[e._v("Note: this has nothing to do with -[CALayer shouldRasterize], which doesn’t\nwork with ASDisplayNode’s asynchronous")]),e._v(" "),i("li",[e._v("rendering model.")])]),e._v(" "),i("p",[e._v("*/")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"注意事项"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#注意事项","aria-hidden":"true"}},[this._v("#")]),this._v(" 注意事项")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[t("p",[this._v("Texture不支持Storyboard和Autolayout，但是可以与使用Autolayout的view兼容共存。同样React native和Component\nKit等其他Facebook出品的iOS库也不支持Storyboard。")])]),this._v(" "),t("li",[t("p",[this._v("由于Node的异步渲染，很有可能在其View到达屏幕之后，内容仍然在渲染过程中。此时需要额外考虑每个Node的placeholder状态，使用户不至于看到一片空白。")])]),this._v(" "),t("li",[t("p",[this._v("在使用ASDisplayNode初始化initWithViewBlock时，由于Node需要在适当的时候调用该block来创建view，因此并不会立即调用block（block可能capture其他变量，例如self），而是存在一个ivar当中。如果该view始终没被创建，而此时拥有该node的父元素被销毁，容易造成retain\ncycle导致memory leak。")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"优缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优缺点","aria-hidden":"true"}},[this._v("#")]),this._v(" 优缺点")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("strong",[this._v("优点")])])},function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("ul",[i("li",[e._v("实现一个layout的视角从专注view之间的constraint转变成对定义多个view子区域的划分，抽象层级变高，可读性大大增强。")]),e._v(" "),i("li",[e._v("由于ASDisplayNode的显示是异步的，因此无论布局是否依赖于显示结果，都可以在主线程以外进行，并且有缓存，性能有很大提升。")]),e._v(" "),i("li",[e._v("借用css成熟的flexbox布局模型，有大量现成资料和案例来学习，避免了新造轮子的尴尬。")]),e._v(" "),i("li",[e._v("由于Texture是开源的，调试难度大大降低。")]),e._v(" "),i("li",[e._v("布局规则可以脱离实际布局对象进行独立声明，容易复用。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("strong",[this._v("缺点")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("由于与iOS原生布局方式完全不同，学习适应需要一定时间（当然如果flexBox渐渐成为前端标准，花一些时间了解也是完全值得的。）")]),this._v(" "),t("li",[this._v("对于ASDK依赖非常重，对于需要使用flexBox布局的view，只能重新使用ASDisplayNode来实现。如果不方便重新写，只能选用类似Yoga的独立框架来实现UIView的流式布局。")]),this._v(" "),t("li",[this._v("虽然是声明式布局，然而相对css而言仍较为繁琐。去年我曾经到Pinterest与Scott有过一些当面交流，也尝试说服他们做一些DSL来简化布局声明，但是目前由于ASDK的复杂性和基础性（类似UIKit），他们仍然将大部分时间放在优化异步渲染和布局性能，并没有太多精力在layout的语法上做出进一步突破。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"深度优化列表性能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#深度优化列表性能","aria-hidden":"true"}},[this._v("#")]),this._v(" 深度优化列表性能")])},function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("ul",[i("li",[e._v("Cell reuse，Apple原生支持")]),e._v(" "),i("li",[e._v("estimated cell height，iOS8开始原生支持")]),e._v(" "),i("li",[e._v("手动将计算完成的height缓存(或使用FDTemplateLayoutCell等框架自动计算)")]),e._v(" "),i("li",[e._v("prefetch API，iOS10开始原生支持")]),e._v(" "),i("li",[e._v("异步加载cell内容，文字图片")]),e._v(" "),i("li",[e._v("圆角、opaque等普通UIView使用")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("strong",[this._v("UITableView加载Cell的过程")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[t("p",[this._v("cellForRowAtIndexPath，读取model")])]),this._v(" "),t("li",[t("p",[this._v("从reuse池中dequeue一个cell，调用prepareForReuse重置其状态")])]),this._v(" "),t("li",[t("p",[this._v("将model装配到UITableViewCell当中去")])]),this._v(" "),t("li",[t("p",[this._v("布局（耗时且无法缓存的Autolayout），渲染（文字和图片都很耗时），显示")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("img",{attrs:{src:i(335),alt:""}})])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("strong",[this._v("ASTableNode/ASCollectionNode开辟的新航路")])])},function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("ul",[i("li",[e._v("ASTableNode/ASCollectionNode，可以认为是UITableView/UICollectionView的异步版本，内部包装了原来的UIKit的对应版本，并扩展了一系列功能使他们能够实现异步布局及渲染。")]),e._v(" "),i("li",[e._v("ASInterfaceState，表示一个node不同的显示状态。其实每个ASDisplayNode都具备interfaceState属性，它主要的用武之地还是在tableNode/collectionNode之中。对于一个UITableViewCell来说，布局和渲染一般都是在cellForRowAtIndexpath同时完成，然而当需要精细处理任务时就需要把每一个不同的状态分开，降低某一瞬间由于CPU负载高导致卡顿的可能性。ASInterfaceState递进地分为5种状态:\n"),i("ul",[i("li",[e._v("None，该node在一段时间内不会进入屏幕")]),e._v(" "),i("li",[e._v("MeasureLayout，可能会在一段时间后进入屏幕，应该准备layout和size计算")]),e._v(" "),i("li",[e._v("Preload，加载所需要的数据，如下载图片，缓存读取等等")]),e._v(" "),i("li",[e._v("Display，马上将要进入屏幕，开始进行渲染操作，显示包含的文字或者图片")]),e._v(" "),i("li",[e._v("Visible，该node（所对应的view）至少有1个像素已经在屏幕内，正在显示")])])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("img",{attrs:{src:i(336),alt:""}})])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("ASDataController，与ASTableNode一一对应，负责代替ASTableNode管理delegate和dataSource的一系列方法，诸如初始化，插入，删除和一些代理方法等。")]),this._v(" "),t("li",[this._v("ASRangeController，同样与ASTableNode一一对应，并且可以根据设备性能自定义布局、加载、渲染的工作indexPath区间，在滚动时动态高效地调整各cell的interfaceState来层层触发不同显示阶段的工作，对于流畅滚动起到了至关重要的作用。")]),this._v(" "),t("li",[this._v("ASScrollDirection，定义了列表滚动的方向（上下左右）。在ASRangeController调整各阶段的工作区间时，一般在用户滚动的方向上需要多加载一些，而滚出屏幕的cell在一定时间内回到屏幕的概率较低，因此其分配到的资源也就相应少一些。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"一些细节"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一些细节","aria-hidden":"true"}},[this._v("#")]),this._v(" 一些细节")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("strong",[this._v("多线程")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("strong",[this._v("监听状态变化")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("strong",[this._v("内存管理")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#小结","aria-hidden":"true"}},[this._v("#")]),this._v(" 小结")])}],r=i(0),n=Object(r.a)({},function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("div",{staticClass:"content"},[e._m(0),e._v(" "),e._m(1),e._v(" "),i("p",[e._v("UITableView/UICollectionView的优化一直是iOS应用性能优化重要的一块。即使是iOS11+iPhone8这样的最新软硬件配置，在系统的信息app中滚动，仔细观察的话仍然能感到一定的掉帧现象。对于UI要求苛刻的苹果竟然在如此简单的tableView上无法达到60fps的帧率，可见优化滚动性能的背后并不简单。")]),e._v(" "),i("p",[e._v("理想状态下，iOS的帧率应该保持在60fps。然而很多情况下用户操作时会感觉到掉帧或者『不跟手』。原因可能有很多，比如以下几种:")]),e._v(" "),i("ul",[e._m(2),e._v(" "),i("li",[i("p",[i("strong",[e._v("Autolayout布局性能瓶颈")]),e._v("，约束计算时间会随着数量呈指数级增长，并且必须在主线程执行。这也是为何Texture抛弃了Autolayout而设计了自己的布局系统的"),i("a",{attrs:{href:"https://github.com/facebookarchive/AsyncDisplayKit/issues/196",target:"_blank",rel:"noopener noreferrer"}},[e._v("重要原因之一"),i("OutboundLink")],1),e._v("。Autolayout在单个View开发时能带来很多便利，而在一些需要高性能的场景下需要谨慎使用。")])]),e._v(" "),e._m(3)]),e._v(" "),i("p",[e._v("UIKit的单线程设计也有一定的历史原因。早在十年前iOS SDK刚问世的时候，mobile\nSDK还是一个非常新的概念，更没有移动多核CPU的存在，因此当时的重点是简单可靠，大多数API都没有支持相对复杂的异步操作。时至今日，如果要完全重构UIKit使之支持异步绘制和布局，对于兼容已有海量的app，难度可想而知。在iOS10中虽然对UICollectionView/UITableView做了一定的预加载优化（WWDC2016 Session219），然而并没有从根本上解决主线程布局和渲染的问题。")]),e._v(" "),e._m(4),e._v(" "),i("p",[e._v("当用户开始滚动或点击一个View，所有的事件都会被送到主线程等待处理。此时主线程能否抽出足够充裕的时间来处理变得极为重要，尤其是在连续操作（如UIGestureRecognizer）时，每次touchMoved事件处理都会占用主线程一定的时间（如新的UIImageView进入视图，主线程开始处理布局或者图片解码，而这些需要连续占用大量CPU时间）。如果一个操作耗时超过16ms(1000ms/60fps)，那就意味着下一帧无法及时得到处理，引起丢帧。")]),e._v(" "),e._m(5),e._v(" "),i("p",[e._v("如何能将主线程的压力尽可能减轻成为优化的首要目标。")]),e._v(" "),i("ol",[i("li",[e._v("针对Autolayout性能优化：提前计算并缓存cell的layout。"),i("a",{attrs:{href:"https://github.com/forkingdog/UITableView-FDTemplateLayoutCell",target:"_blank",rel:"noopener noreferrer"}},[e._v("forkingdog"),i("OutboundLink")],1)]),e._v(" "),i("li",[e._v("省去中间滑动过程中的计算，直接计算目标区域cell。"),i("a",{attrs:{href:"https://github.com/johnil/VVeboTableViewDemo",target:"_blank",rel:"noopener noreferrer"}},[e._v("VVebotableViewDemo"),i("OutboundLink")],1)]),e._v(" "),i("li",[e._v("弃用Autolayout，采用手动布局计算。这样虽然可以换来最高的性能，但是代价是编写和维护的不便，对于经常改动或者性能要求不高的场景并不一定值得。")]),e._v(" "),i("li",[e._v("自行"),i("a",{attrs:{href:"https://github.com/ibireme/YYAsyncLayer",target:"_blank",rel:"noopener noreferrer"}},[e._v("异步渲染Layer"),i("OutboundLink")],1)]),e._v(" "),i("li",[e._v("iOS11列表的prefetch API，只是并没有解决Autolayout的性能，同时也受到系统版本限制。")])]),e._v(" "),e._m(6),e._v(" "),i("p",[e._v("对于一般的开发者，自己重新实现一整套异步布局和渲染机制是非常困难的，但是Texture做到了。")]),e._v(" "),i("p",[i("code",[e._v("Texture")]),e._v("前身是AsyncDisplayKit，是2012年由Facebook开始着手开发，并于2014年出品的高性能显示类库，主要作者是Scott Goodson"),i("a",{attrs:{href:"https://github.com/appleguy",target:"_blank",rel:"noopener noreferrer"}},[e._v("appleguy"),i("OutboundLink")],1),e._v("曾经参与了多个iOS版本系统的开发，包括UIKit以及一些系统原生app，后来加入Facebook并参与了Texture的开发并应用到Paper，因此该库有机会从相对底层的角度来进行一系列的优化。同时由于和Instagram同处于FB家族，因此也迅速加入了IGListKit的支持。")]),e._v(" "),i("p",[e._v("在Scott介绍Texture的视频中，总结了一下三点占用大量CPU时间的『元凶』（虽然仍然可能有以上提到的其他原因，但Texture最主要集中于这三点进行优化：")]),e._v(" "),e._m(7),e._v(" "),i("p",[e._v("既然同步就意味着阻塞，那就异步放到其他线程去做，在需要主线程时再同步回来。")]),e._v(" "),e._m(8),e._v(" "),i("p",[e._v("对于一般UIView和CALayer来说，因为不是线程安全的，任何相关操作都需要在主线程进行。正如UIView可以弥补CALayer无法处理用户事件的不足一样，Texture引入了Node的概念来解决UIView/CALayer只能在主线程上操作的限制（不由让人想起『Abstract layer can solve many problems, except problem of having too many abstract layers.』）。")]),e._v(" "),i("p",[e._v("Texture主要特点如下：")]),e._v(" "),e._m(9),e._v(" "),i("p",[e._v("举例来说，当使用UIKit创建一个UIImageView：")]),e._v(" "),e._m(10),i("p",[e._v("使用Texture后只要稍加改动：")]),e._v(" "),e._m(11),i("p",[e._v("虽然只是简单的把View替换成了Node，然而和UIImageView不同的是，此时Texture已经在悄悄使用另一个线程进行图片解码，从而大大降低新的用户操作到来时主线程被阻塞的概率，使每一个回调都能得到及时的处理。实践中将会有更加复杂的情况，有兴趣的话可以参考项目中的Example目录，有20多个不同场景下的示例项目。")]),e._v(" "),e._m(12),e._v(" "),e._m(13),e._v(" "),e._m(14),e._v(" "),i("p",[e._v("ASDisplayNode还有一个属性shouldRasterizeDescendants。")]),e._v(" "),e._m(15),e._v(" "),i("p",[e._v("当我们不需要分别关注单个CALayer，也不需要对他们进行操作时，就可以将所有的子node都合并到父node的backing\nstore一并绘制，从而达到节省内存和提高性能的目的。")]),e._v(" "),e._m(16),e._v(" "),e._m(17),e._v(" "),e._m(18),e._v(" "),e._m(19),e._v(" "),e._m(20),e._v(" "),e._m(21),e._v(" "),e._m(22),e._v(" "),e._m(23),e._v(" "),i("p",[e._v("说到视图性能，不能不提到UITableView，对于它的滚动性能的讨论和优化从未停止。在我们的探索过程中，尝试过以下一些措施：")]),e._v(" "),e._m(24),e._v(" "),e._m(25),e._v(" "),e._m(26),e._v(" "),i("p",[e._v("这些操作都在cell将要进入window的一刹那发生，不难理解，在短短的16ms里（60fps）是很难完成这些任务的，尤其是当用户快速滚动的时候，大量任务堆积在runloop，情况变得雪上加霜。如果将滚动中的CPU占用情况用图表显示出来，大概是这样的:")]),e._v(" "),e._m(27),e._v(" "),e._m(28),e._v(" "),i("p",[e._v("ASTableNode以及其cellNode已经具备了异步布局和异步渲染的能力，即使没有做额外优化，仅仅利用A异步机制将耗时操作延后，相对于一般UITableView已经有了显著的提升。虽然性能锯齿仍然存在，但是将其转移到了后台线程以后，用户感受到的卡顿就已经不会那么明显了。然而在进入屏幕之后才开始渲染的时候会有短暂的白屏现象(等待渲染完成)再显示内容。既然渲染工作可以在显示之后再进行，那么类似的，也可以在显示之前的一段时间，把布局和渲染的工作预先完成。")]),e._v(" "),i("p",[e._v("要达到这些目的，首先介绍一些相关的类：")]),e._v(" "),e._m(29),e._v(" "),e._m(30),e._v(" "),i("p",[e._v("对于每一个cell而言，原本需要在同一时间点进行的所有初始化/加载/布局/渲染等工作，现在被均匀分配到了不同的状态进行预处理。随着用户滚动列表，根据cell离屏幕的距离不同，设置相应的interfaceState并触发不同阶段的工作，达到均匀分配的目的。同时，由于不需要在主线程上进行，多个cell的工作可以通过共享后台线程来大幅提高并行效率。")]),e._v(" "),e._m(31),e._v(" "),e._m(32),e._v(" "),e._m(33),e._v(" "),i("p",[e._v("当同时layout多个node时，如何均匀分配工作到各个线程，同时单次不占用过多cpu时间？")]),e._v(" "),i("p",[e._v("Texture是这么做的：")]),e._v(" "),i("p",[e._v("获取当前设备上cpu的数量，并乘以每个cpu的工作量，如4 * 5 = 20，即同一批最多对20个node进行布局。（尽管没有找到严格的文档来说明这样的计算方式会带来最高的效率，但是应该要比不分批次处理更优，使占用的cpu时间片可控）\n调用dispatch_apply，对同一批次20个node进行并行布局计算\n每一批处理20个，直到所有都处理完")]),e._v(" "),e._m(34),e._v(" "),i("p",[e._v("不光ASDisplayNode本身会根据不同的state进行相应的工作，它同时也提供了一系列的方法供子类override，如didEnterPreloadState/didExitVisibleState等等。在实际应用中，由于子类通常会持有一些自己管理的资源（如图片），需要控制在显示/离开屏幕之际进行资源的分配/回收。由于每个时间点分的比较细，只要将工作均匀、合理地分配到相应的方法中，就可以实现非常精确高效的资源调度。")]),e._v(" "),e._m(35),e._v(" "),i("p",[e._v("ASRangeController经常需要管理屏幕外的node（可能同时有好几屏的内容同时进行布局计算和显示），通过预处理来减轻将来的工作量，是一个典型的『空间换时间』的办法，对于内存的压力自然就会上升。")]),e._v(" "),i("p",[e._v("为此，ASRangeController提供了一些参数，让开发者可以自行决定每个stage所囊括的范围，达到控制内存的：")]),e._v(" "),i("p",[e._v("ASLayoutRangeModeFull，此时用到的资源较多，同时用户体验也是最好的\nASLayoutRangeMinimum，比上一种类型节省一些资源\nASLayoutRangeModeVisibleOnly，在app退到后台的时候自动设置，将屏幕外的node所占用的资源释放，降低app在系统中被杀的概率\nASLayoutRangeModeLowMemory，比上一种更省内存，对于app退到后台，并且目前没有在屏幕上（可能在navigation stack里）的rangeController适用，最大程度释放资源\n我们可以通过调用setTuningParameters的方式，对于每一种mode中的每一种layoutRangeType做出精细调整。同时，ASDK会自动根据此时node在屏幕上的情况，自动在以上几种mode中来回切换，并根据指定的参数范围来加载/释放资源，达到资源和性能的平衡。")]),e._v(" "),e._m(36),e._v(" "),i("p",[e._v("由于Texture的基本理念是在需要创建UIView时替换成对应的Node来获取性能提升，因此对于现有代码改动较大，侵入性较高，同时由于大量原本熟悉的操作变成了异步的，对于一个团队来说学习曲线也较为陡峭。")]),e._v(" "),i("p",[e._v("从我们在实际项目中的经验，结合Scott的建议来看，不需要也不可能将所有UIView都替换成其Node版本。将注意力集中在可能造成主线程阻塞的地方，如tableView/collectionView、复杂布局的View、使用连续手势的操作等等。找到合适的切入点将一部分性能需求较高的代码替换成Texture，会是一个较好的选择。")])])},a,!1,null,null,null);t.default=n.exports}}]);