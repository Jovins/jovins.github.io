(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{423:function(e,t,r){"use strict";r.r(t);var n=r(0),o=Object(n.a)({},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("div",{staticClass:"content"},[e._m(0),e._v(" "),r("p",[r("a",{attrs:{href:"https://davedelong.com/blog/2017/11/06/a-better-mvc-part-1-the-problems/",target:"_blank",rel:"noopener noreferrer"}},[e._v("A Better MVC, Part 1: The Problems | Dave DeLong"),r("OutboundLink")],1),e._v("\n问题：")]),e._v(" "),e._m(1),e._v(" "),r("p",[e._v("解决办法：\n开发者为了解决上面两个问题通常会使用其它架构方式。但是会增加团队成员的学习成本。系统更新时也有可能需要更多时间来进行适配，同样地，如果你依赖了其它第三库，还需要等得第三库的更新。")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://davedelong.com/blog/2017/11/06/a-better-mvc-part-2-fixing-encapsulation/",target:"_blank",rel:"noopener noreferrer"}},[e._v("A Better MVC, Part 2: Fixing Encapsulation | Dave DeLong"),r("OutboundLink")],1),e._v("\n对 View Controller 进行解耦，View Controller 不需要知道其它 View Controller ，做法是生成一个更高层 View Controller，这个 View Controller 不包含其它逻辑，只负责对 View Controller 的跳转进行处理。所有子 View Controller 都通过它来进行跳转。")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://davedelong.com/blog/2017/11/06/a-better-mvc-part-3-fixing-massive-view-controller/",target:"_blank",rel:"noopener noreferrer"}},[e._v("A Better MVC, Part 3: Fixing Massive View Controller | Dave DeLong"),r("OutboundLink")],1),e._v("\n1 View Controller ≠ 1 screen of content\n开始写 app 时，我们都会使用一个 View Controller 来表示一个屏幕的内容，但是当 app 变得复杂时，我们可以将某些比较复杂的界面分成多个小的 View Controller。")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://davedelong.com/blog/2017/11/06/a-better-mvc-part-4-future-directions/",target:"_blank",rel:"noopener noreferrer"}},[e._v("A Better MVC, Part 4: Future Directions | Dave DeLong"),r("OutboundLink")],1),e._v("\n承接上面所说的 1 View Controller ≠ 1 screen of content，单个 cell 也可以使用单个 ViewController 来管理，将 cell 中的逻辑分离出来。\n总结：")]),e._v(" "),e._m(2),e._v(" "),r("p",[r("a",{attrs:{href:"https://davedelong.com/blog/2018/04/24/a-better-mvc-part-5-an-evolution/",target:"_blank",rel:"noopener noreferrer"}},[e._v("A Better MVC, Part 5: An Evolution | Dave DeLong"),r("OutboundLink")],1),e._v("\n作者在五个月后又写了一篇关于 MVC 的文章。\nMVC 不是一种设计模式，是一种思想，它追求封装，将不同的东西分隔开来。\nView Controller 其实不是 Controller，而是 View，它负责的其实是 View 相关的逻辑。\nView Controller 应该只负责处理业务逻辑或者传递数据给它包含的 UIViews，不应该两者都包含。\nUIViewControllers 应该只负责下面的其中一个部分：")]),e._v(" "),e._m(3),e._v(" "),r("p",[r("a",{attrs:{href:"https://www.avanderlee.com/optimization/measure-performance-code/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.avanderlee.com/optimization/measure-performance-code/"),r("OutboundLink")],1),e._v("\n检测代码性能: Xcode unit test，playground 和 terminal，playground 因为涉及到 UI 的更新，所以检测到的代码执行时间会其它两个大，其它两个的结果比较接近。")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://onevcat.com/2018/10/swift-result-error/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Result 还是 Result"),r("OutboundLink")],1),e._v(" "),r("code",[e._v("Result<T, E: Error>")]),e._v(" 和 "),r("code",[e._v("Result<T>")]),e._v(" 的比较。")]),e._v(" "),e._m(4),e._v(" "),r("p",[r("a",{attrs:{href:"https://onevcat.com/2018/11/defer/",target:"_blank",rel:"noopener noreferrer"}},[e._v("关于 Swift defer 的正确使用"),r("OutboundLink")],1),e._v(" "),r("code",[e._v("defer")]),e._v(" 的目的就是进行资源清理和避免重复的返回前需要执行的代码，而不是用来以取巧地实现某些功能。这样做只会让代码可读性降低。")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://swift.gg/2018/11/19/useful-optional-extensions/",target:"_blank",rel:"noopener noreferrer"}},[e._v("实用的可选项（Optional）扩展"),r("OutboundLink")],1),e._v("\nOptional 的一些扩展。")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://www.objc.io/blog/2018/11/13/subclassing-alternatives",target:"_blank",rel:"noopener noreferrer"}},[e._v("Swift Tip: Custom Views Without Subclassing · objc.io"),r("OutboundLink")],1),e._v("\n如果只是创建一个 view 后不再进行改变，可以使用一个简单的 functino 来进行创建，而不是自定义一个 subView 。")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://www.objc.io/blog/2018/11/20/local-structs/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Swift Tip: Local Struct Definitions · objc.io"),r("OutboundLink")],1),e._v("\n为避免占用命名空间，可将只使用一次的类或者结构体放到函数中。")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://www.avanderlee.com/swift/custom-operators-swift/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Custom Operators in Swift with considerations for readability - SwiftLee"),r("OutboundLink")],1),e._v("\n如果是在频繁使用的可以考虑使用 custom operators，但是需要考虑代码的可读性。")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://swiftrocks.com/whats-type-and-self-swift-metatypes.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("What’s .self, .Type and .Protocol? Understanding Swift Metatypes - SwiftRocks"),r("OutboundLink")],1),e._v("\nSwift 元类型，介绍了动态元类型 "),r("code",[e._v("type(of:)")]),e._v(" 和静态元类型 "),r("code",[e._v(".self")]),e._v("\n以及协议的元类型用法。")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://www.swiftbysundell.com/posts/avoiding-race-conditions-in-swift",target:"_blank",rel:"noopener noreferrer"}},[e._v("Avoiding race conditions in Swift"),r("OutboundLink")],1),e._v("\n避免竞态条件，讲述两种可能出现竞态条件的情况，多线程和多次请求导致一些不符合预期的情况出现。")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://nshipster.cn/hashable/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://nshipster.cn/hashable/"),r("OutboundLink")],1),e._v("\nHash在 swift 中的进化史")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://www.appcoda.com/memory-management-swift/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.appcoda.com/memory-management-swift/"),r("OutboundLink")],1),e._v("\nstrong weak 与 unowned")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://oleb.net/2018/photos-data-model/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://oleb.net/2018/photos-data-model/"),r("OutboundLink")],1),e._v("\nPhotoKit 是 iOS 提供给 app 进行相册相关操作的框架，作者从中发现了数据层部分是使用 CoreData 来编写的，讲述如何发现是使用 CreData 以及如何使用 Xcode 结合 .mom 文件来查看 Data Model 的结构")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://swiftrocks.com/writing-cleaner-view-code-by-overriding-loadview.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://swiftrocks.com/writing-cleaner-view-code-by-overriding-loadview.html"),r("OutboundLink")],1),e._v("\n如何通过 UIViewController 中的 loadView 方法来自义 ViewCtroller 的 view，从而达到将 ViewCtroller 中配置 view 的相关代码分离出来的目的，也可以结合 protocol 来减少要编写的模版代码，不过也有一些缺点。")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://swiftrocks.com/swift-associated-types-with-default-values.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://swiftrocks.com/swift-associated-types-with-default-values.html"),r("OutboundLink")],1),e._v("\n为 protocol 的关联类型提供默认值")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://www.swiftbysundell.com/posts/lightweight-presenters-in-swift",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.swiftbysundell.com/posts/lightweight-presenters-in-swift"),r("OutboundLink")],1),e._v("\n轻量的 Presenter 设计模式，套多一层中间层 Presenter 来分离各 ViewController ，各 ViewController 不直接调用其它 ViewController ，而是通过 Presenter 来进行调用。")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://www.avanderlee.com/swift/updating-swift-4-2/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.avanderlee.com/swift/updating-swift-4-2/"),r("OutboundLink")],1),e._v("\nSwift 4.2 一些变化\n可以使用 self 来替代 strongSelf\n使用 #warning 来替代 //MARK todo\n使用 allCases 获取 enum 类型的所有 cases\n使用 random 获取随机值或者 shuffled 获取打乱的数组")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://www.avanderlee.com/optimization/analysing-build-performance-xcode-10/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.avanderlee.com/optimization/analysing-build-performance-xcode-10/"),r("OutboundLink")],1),e._v("\nXcode 10 中的 Build 性能分析，Xcode 10新增了一个 Build With Time Summary 的性能检测，可以分析 Build 的过程中具体过程所消耗的时间。\n改进办法：\nType checking of functions and expressions\n类型判断有时会消耗很长的时间，可以通过设置 -Xfrontend -warn-long-expression-type-checking= 来检测那些超过 limit（时间限制，ms）的表达式，同样的，对于函数，可以使用 -Xfrontend -warn-long-function-bodies= 来开启检测。")]),e._v(" "),r("p",[e._v("在 debug 中开启 Whole Module 也可以优化 Build 性能。")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://www.avanderlee.com/xcode/optin-features-xcode-10/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.avanderlee.com/xcode/optin-features-xcode-10/"),r("OutboundLink")],1),e._v("\nXcode 10 中一些配置：Code folding ，Whole Module 等。")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://www.swiftbysundell.com/posts/reusable-data-sources-in-swift",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.swiftbysundell.com/posts/reusable-data-sources-in-swift"),r("OutboundLink")],1),e._v("\n将 dataSources 从 View Controller 中分离出来，进行复用。")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://www.objc.io/blog/2018/09/18/imperative-or-functional/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.objc.io/blog/2018/09/18/imperative-or-functional/"),r("OutboundLink")],1),e._v("\n如何结合命令式和函数式编程的 tips")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://www.swiftbysundell.com/posts/different-flavors-of-view-models-in-swift",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.swiftbysundell.com/posts/different-flavors-of-view-models-in-swift"),r("OutboundLink")],1),e._v("\n使用 View Model 将逻辑从 View Controller 中分离出来")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://www.avanderlee.com/swift/performance-collections/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.avanderlee.com/swift/performance-collections/"),r("OutboundLink")],1),e._v("\n集合中函数式操作的性能优化\n使用 "),r("code",[e._v("contains")]),e._v(" 代替 "),r("code",[e._v("first(where:) != nil")]),e._v("\n使用 "),r("code",[e._v("isEmpty")]),e._v(" 代替 count 与 0 比较\n使用 "),r("code",[e._v("isEmpty")]),e._v(" 来检测 String 是否为空\n使用 "),r("code",[e._v("first(where:)")]),e._v(" 来代替 "),r("code",[e._v("filter")]),e._v(" 后面追加 "),r("code",[e._v("first")]),e._v("\n使用 "),r("code",[e._v("max()")]),e._v(" 和 "),r("code",[e._v("min()")]),e._v(" 开代替 "),r("code",[e._v("sorted()")]),e._v(" 后的 "),r("code",[e._v("first")]),e._v(" 和 "),r("code",[e._v("last")]),e._v("\n使用 "),r("code",[e._v("allSatisfy(_:)")]),e._v(" 来代替 "),r("code",[e._v("filter")]),e._v(" 结合 "),r("code",[e._v("isEmpty")]),e._v(" 判断是否所有对象都符合某个条件")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://nshipster.cn/ios-12/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://nshipster.cn/ios-12/"),r("OutboundLink")],1),e._v("\niOS 12的一些变化\n跟 app 开发有关的有：\n在 iOS 12 的新 API 里，你可以把 URLRequest 对象networkServiceType 设置为 NSURLNetworkServiceTypeResponsiveData，从而让一些时间敏感的操作优先请求。\n根据电话号码和邮件地址匹配联系人。\n新密码的自动输入与一次性验证码在文本框里的输入。")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://nshipster.cn/cmmotionactivity/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://nshipster.cn/cmmotionactivity/"),r("OutboundLink")],1),e._v("\nCMMotionActivityManager 处理设备中传感器的原始数据并告诉你（有多确定）用户是否正在移动，和用户是在行走、跑步、骑行或者开车")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://swift.gg/2018/10/15/creating-and-modifying-nsurl-in-swift-4/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://swift.gg/2018/10/15/creating-and-modifying-nsurl-in-swift-4/"),r("OutboundLink")],1),e._v("\nSwift 中 URL 的相关方法")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://swift.gg/2018/08/28/swift-generics/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Swift 4 泛型：如何在你的代码或App里应用泛型"),r("OutboundLink")],1),e._v("\n如何在 Swift 中应用泛型，比较基础。")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://swift.gg/2018/09/18/properties-in-swift/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Swift 中的属性"),r("OutboundLink")],1),e._v("\nSwift 属性相关说明，一些属性相关的基础用法。")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://www.avanderlee.com/swift/defer-usage-swift/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Defer usage in Swift"),r("OutboundLink")],1),e._v("\ndefer 在 swift 中的运行机制，defer 的执行顺序是按照声明顺序倒序执行，介绍了几个在 swift 中使用 defer 的场景，可以预先设定在函数完成后需要执行的方法。我大部分用到 defer 的场景就是取消 tableView/collectionView 的选中效果。")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://www.avanderlee.com/swift/compactmap-flatmap-differences-explained/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CompactMap vs flatMap: The differences explained"),r("OutboundLink")],1),e._v("\ncompactmap 与 flatmap 的不同之处，如果数组为 optional ，想转换为 nonoptional，则使用 compactmap ，flatmap 则是将多维数组降为一维。")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://swift.gg/2018/08/30/never/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Never"),r("OutboundLink")],1),e._v("\n介绍了 "),r("code",[e._v("Never")]),e._v(" 这个无实例类型，以及如何使用 "),r("code",[e._v("Never")]),e._v(" 来优化代码中的不可能情况。")]),e._v(" "),r("p",[r("a",{attrs:{href:"http://alisoftware.github.io/swift/protocols/2018/09/02/protocols-private-properties/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Private properties in protocols "),r("OutboundLink")],1),e._v("\n在 Swift 中，protocols 不支持定义属性的访问控制权，但是有时候你不想暴露这些属性。这篇文章介绍了如何使用一个嵌套类型和 "),r("code",[e._v("fileprivate")]),e._v(" 来使得属性私有化。")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://www.objc.io/blog/2018/09/04/switching-with-associated-values/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Switching with Associated Values"),r("OutboundLink")],1),e._v("\n如何在多重 "),r("code",[e._v("switch")]),e._v(" 中优化代码。")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://www.appcoda.com/design-pattern-creational/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Design Patterns in Swift #1: Factory Method and Singleton"),r("OutboundLink")],1),e._v(" "),r("a",{attrs:{href:"https://www.appcoda.com/design-pattern-behavorial/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Design Patterns in Swift #2: Observer and Memento"),r("OutboundLink")],1),e._v(" "),r("a",{attrs:{href:"https://www.appcoda.com/design-pattern-structural",target:"_blank",rel:"noopener noreferrer"}},[e._v("Design Patterns in Swift #3: Facade and Adapter"),r("OutboundLink")],1),e._v("\n设计模式三连发。\n第一篇为工厂模式和单例模式，工厂模式结合 "),r("code",[e._v("protocol")]),e._v(" 对类进行抽象。\n第二篇为观察者模式和备忘录模式，观察者模式结合了 "),r("code",[e._v("protocol")]),e._v(" 和 "),r("code",[e._v("enum")]),e._v(" 来讲述如何实现在 Swift 中实现观察者模式，备忘录模式则是 "),r("code",[e._v("protocol")]),e._v(" 和 "),r("code",[e._v("UserDefaults")]),e._v(" 相结合来实现数据持久化。\n第三篇为外观模式和适配器模式，外观模式还是通过 "),r("code",[e._v("protocol")]),e._v(" 进行封装成统一的接口。适配器模式也是结合 "),r("code",[e._v("protocol")]),e._v(" 来说明如何对接口进行调整。")])])},[function(){var e=this.$createElement,t=this._self._c||e;return t("h1",{attrs:{id:"reading-list"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reading-list","aria-hidden":"true"}},[this._v("#")]),this._v(" Reading List")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ol",[t("li",[this._v("违反封装，充斥着大量面条代码")]),this._v(" "),t("li",[this._v("Massview View Controller")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("使用 View Controllers 来分解 UI")]),this._v(" "),t("li",[this._v("使用 View Controllers 来管理列表控件")]),this._v(" "),t("li",[this._v("View Controllers 不一定要填充屏幕")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ol",[t("li",[t("p",[this._v("组合 Child View Controller")])]),this._v(" "),t("li",[t("p",[this._v("给自己拥有的 UIViews 填充数据")]),this._v(" "),t("blockquote",[t("p",[this._v("So instead of saying a UIViewController should “manage either sequence or UI”, perhaps a better way of saying it would be that a UIViewController should either compose children or put stuff in to UIViews (with the understanding that this is a guideline, and not a rule).")])])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("blockquote",[t("p",[this._v("因为 Swift 并没有提供使用协议类型作为泛型中特化的具体类型的支持，这导致在 API 的强类型严谨性和灵活性上无法取得两端都完美的做法。硬要对比的话，可能 Result<T, E: Error> 对使用者更加友好一些，因为它提供了一个定义错误类型的机会。但是相对地，如果创建者没有掌握好错误类型的程度，而将多层嵌套的错误传递时，反而会增加使用者的负担。同时，由于错误类型被限定，导致 API 的变更要比只定义了结果类型的 Result 困难得多。")])])}],!1,null,null,null);t.default=o.exports}}]);